//=========================================================================//
//-------------------------------------------------------------------------//
// e2cmdw.cpp -- Command Window (main user interfaces)                     //
// This file is part of PonyProg.                                          //
//-------------------------------------------------------------------------//
//                                                                         //
//  PonyProg - Serial Device Programmer                                    //
//                                                                         //
//  Copyright (C) 1997-2000   Claudio Lanconelli                           //
//                                                                         //
//  e-mail: lanconel@cs.unibo.it                                           //
//  http://www.cs.unibo.it/~lanconel                                       //
//                                                                         //
//-------------------------------------------------------------------------//
//                                                                         //
// This program is free software; you can redistribute it and/or           //
// modify it under the terms of the GNU  General Public License            //
// as published by the Free Software Foundation; either version2 of        //
// the License, or (at your option) any later version.                     //
//                                                                         //
// This program is distributed in the hope that it will be useful,         //
// but WITHOUT ANY WARRANTY; without even the implied warranty of          //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       //
// General Public License for more details.                                //
//                                                                         //
// You should have received a copy of the GNU  General Public License      //
// along with this program (see COPYING);     if not, write to the         //
// Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. //
//                                                                         //
//-------------------------------------------------------------------------//
//=========================================================================//

# define	VERSIONE	"1.17a Beta"

//======================================================================
//@V@:Note: The scheleton for this file generated by vgen V1.02
//	e2cmdw.cpp:	Source for e2CmdWindow class
//=======================================================================
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <v/vicon.h>
#include <v/vnotice.h>	// for vNoticeDialog
#include <v/vynreply.h>	// for vYN dialog
#include <v/vreply.h>
#include <v/vfilesel.h>
#include <v/vkeys.h>	// to map keys
#include <v/vprintdc.h>
#include <v/vprinter.h>

#include <v/vcolor.h>

#include "e2app.h"
#include "e2awinfo.h"
#include "e2cmdw.h"		// our header
#include "infomdlg.h"
#include "filldlg.h"
#include "retrymdlg.h"
#include "fusemdlg.h"

#include "socksrv.h"

//	Start defines for the main window with 100
#include "cmdenum.h"

#ifdef	_LINUX_
# define	DEF_TITLE	APPNAME " - No Name"
# define	DEF_FNAME	"No Name"
# define	STR_TITLE	APPNAME " - %s"
#else
# define	DEF_TITLE	"No Name"
# define	DEF_FNAME	"No Name"
# define	STR_TITLE	"%s"

#  ifdef	__BORLANDC__
#    define	strcasecmp stricmp
#  else // _MICROSOFT_ VC++
#    define strcasecmp	stricmp
#  endif
#endif


//@V@:BeginPulldownMenu FileMenu
static vMenu FileMenu[] =
{
	{"&New", M_New, isSens, notChk, noKeyLbl, noKey, noSub},
	{"&Open...", M_Open, isSens, notChk, noKeyLbl, noKey, noSub},
	{"&Save", M_Save, isSens, notChk, noKeyLbl, noKey, noSub},
	{"Save &as...", M_SaveAs, isSens, notChk, noKeyLbl, noKey, noSub},
	{"&Print...", M_Print, isSens, notChk, noKeyLbl, noKey, noSub},
#ifdef	vDEBUG
	{"-", M_Line, notSens, notChk, noKeyLbl, noKey, noSub},
	{"&Debug", M_SetDebug, isSens, notChk, noKeyLbl, noKey, noSub},
#endif
	{"-", M_Line, notSens, notChk, noKeyLbl, noKey, noSub},
	{"&Close", M_Close, isSens, notChk, noKeyLbl, noKey, noSub},
	{"E&xit", M_Exit, isSens, notChk, noKeyLbl, noKey, noSub},
	{"-", M_Line, notSens, notChk, noKeyLbl, noKey, noSub},
	{" ", m_File1, isSens, notChk, noKeyLbl, noKey, noSub},
	{" ", m_File2, isSens, notChk, noKeyLbl, noKey, noSub},
	{NULL}
};
//@V@:EndPulldownMenu

//@V@:BeginPulldownMenu EditMenu
static vMenu EditMenu[] =
{
//	{"Cut  ", M_Cut, isSens, notChk, "Ctrl-X", 'X'-'@', noSub},
//	{"Copy ", M_Copy, isSens, notChk, "Ctrl-C", 'C'-'@', noSub},
//	{"Paste", M_Paste, isSens, notChk, "Ctrl-V", 'V'-'@', noSub},
//	{"-", M_Line, notSens, notChk, noKeyLbl, noKey, noSub},
	{"Edit &Note...", m_Note, isSens, notChk, noKeyLbl, noKey, noSub},
	{"Security &Bits...",m_SpecBits,isSens,notChk,noKeyLbl,noKey,noSub},
	{"-", M_Line, notSens, notChk, noKeyLbl, noKey, noSub},
	{"Edit Bu&ffer enabled", m_EditBuf, isSens, notChk, noKeyLbl, noKey, noSub},
	{NULL}
};
//@V@:EndPulldownMenu

struct Menu2Type {
	int menu_id;
	long type;
};

static Menu2Type index_menu_type[] = {
	//AutoTag
	//List of menu item to device type
	{m_24XX, E2400},
	{m_2402, E2402},
	{m_2404, E2404},
	{m_2408, E2408},
	{m_2416, E2416},
	{m_24645, E24645},
	{m_24325, E24325},
	{m_2432, E2432},
	{m_2464, E2464},
	{m_24128, E24128},
	{m_24256, E24256},
	{m_24512, E24512},
	{m_at90sXXXX, AT90S0000},
	{m_at90s1200, AT90S1200},
	{m_at90s2313, AT90S2313},
	{m_at90s4414, AT90S4414},
	{m_at90s8515, AT90S8515},
	{m_atmega603, ATmega603},
	{m_atmega103, ATmega103},
	{m_at90s2323, AT90S2323},
	{m_at90s2333, AT90S2333},
	{m_at90s2343, AT90S2343},
	{m_at90s4433, AT90S4433},
	{m_at90s4434, AT90S4434},
	{m_at90s8534, AT90S8534},
	{m_at90s8535, AT90S8535},
	{m_attiny12, ATtiny12},
	{m_attiny22, ATtiny22},

	{m_at89s8252, AT89S8252},
	{m_at89s53, AT89S53},
	{m_9306, E9306},
	{m_9346, E9346},
	{m_9356, E9356},
	{m_9366, E9366},
	{m_9376, E9376},
	{m_9386, E9386},
	{m_pic1684, PIC1684},
	{m_25010, E25010},
	{m_25020, E25020},
	{m_25040, E25040},
	{m_25080, E25080},
	{m_25160, E25160},
	{m_25320, E25320},
	{m_25640, E25640},
	{m_25128, E25128},
	{m_25256, E25256},
	{m_sde2506, E2506},

	{0,0}
};

//AutoTag
//List of vmenu items (device type)

static vMenu i2cMenu[] = {
	{"", m_24XX, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_2402, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_2404, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_2408, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_2416, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_24325, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_24645, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_2432, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_2464, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_24128, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_24256, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_24512, isSens, notChk, noKeyLbl, noKey, noSub},
	{NULL}
};

static vMenu spiMenu[] = {
	{"", m_25010, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_25020, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_25040, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_25080, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_25160, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_25320, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_25640, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_25128, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_25256, isSens, notChk, noKeyLbl, noKey, noSub},
	{NULL}
};

static vMenu microwireMenu[] = {
	{"", m_9306, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_9346, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_9356, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_9366, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_9376, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_9386, isSens, notChk, noKeyLbl, noKey, noSub},
	{NULL}
};

static vMenu avrMenu[] = {
	{"", m_at90sXXXX, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at90s1200, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at90s2313, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at90s2323, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at90s2333, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at90s2343, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at90s4414, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at90s4433, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at90s4434, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at90s8515, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at90s8534, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at90s8535, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_atmega603, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_atmega103, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_attiny12, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_attiny22, isSens, notChk, noKeyLbl, noKey, noSub},
	{NULL}
};

static vMenu at89sMenu[] = {
	{"", m_at89s8252, isSens, notChk, noKeyLbl, noKey, noSub},
	{"", m_at89s53, isSens, notChk, noKeyLbl, noKey, noSub},
	{NULL}
};


static vMenu picMenu[] = {
	{"", m_pic1684, isSens, notChk, noKeyLbl, noKey, noSub},
	{NULL}
};

static vMenu TypeMenu[] =
{
	{"&I2C Bus eeprom", m_I2Cbus, isSens, notUsed, notUsed, noKey, &i2cMenu[0]},
	{"&MicroWire eeprom", m_MicroWire, isSens, notUsed, notUsed, noKey, &microwireMenu[0]},
	{"&SPI eeprom", m_SPI, isSens, notUsed, notUsed, noKey, &spiMenu[0]},
	{"&AVR micro", m_AVR, isSens, notUsed, notUsed, noKey, &avrMenu[0]},
	{"AT&89S micro", m_at89s, isSens, notUsed, notUsed, noKey, &at89sMenu[0]},
	{"&PIC micro", m_PIC, isSens, notUsed, notUsed, noKey, &picMenu[0]},
	{"", m_sde2506, isSens, notChk, noKeyLbl, noKey, noSub},

	{NULL}
};

static vMenu EepromMenu[] =
{
	{"&Select", m_Type,isSens,notChk,noKeyLbl,noKey, &TypeMenu[0]},
	{"&Read ", m_Read, isSens, notChk, noKeyLbl, noKey, noSub},
	{"&Write", m_Write,isSens, notChk, noKeyLbl, noKey, noSub},
	{"&Verify",m_Verify,isSens,notChk, noKeyLbl, noKey, noSub},
	{"&Erase",m_Erase,isSens,notChk,noKeyLbl,noKey,noSub},
	{"Re&adSecurity",m_ReadSecurity,isSens,notChk,noKeyLbl,noKey,noSub},
	{"Wr&iteSecurity",m_WriteSecurity,isSens,notChk,noKeyLbl,noKey,noSub},
	{"&GetInfo",m_Info,isSens, notChk, noKeyLbl, noKey, noSub},
	{"Rese&t",m_Reset,isSens, notChk, noKeyLbl, noKey, noSub},
	{NULL}
};

//@V@:BeginPulldownMenu Options
static vMenu OptionsMenu[] =
{
	{"&Setup", m_Setup, isSens, notChk, noKeyLbl, noKey, noSub},
	{"&Calibration", m_Calibration, isSens, notChk, noKeyLbl, noKey, noSub},
	{"&Remote Mode", m_Remote, isSens, notChk, noKey, noSub},
	{NULL}
};
//@V@:EndPulldownMenu

//@V@:BeginPulldownMenu Options
static vMenu UtilityMenu[] =
{
	{"&ClearBuffer",m_ClearBuf,isSens,notChk,noKeyLbl,noKey,noSub},
	{"&FillBuffer",m_FillBuf,isSens,notChk,noKeyLbl,noKey,noSub},
	{"&DoubleBank",m_DoubleSize,isSens,notChk,noKeyLbl,noKey,noSub},
	{"&ByteSwap", m_ByteSwap,isSens,notChk,noKeyLbl,noKey,noSub},
//	{"ReadSecurity",m_ReadSecurity,isSens,notChk,noKeyLbl,noKey,noSub},
//	{"WriteSecurity",m_WriteSecurity,isSens,notChk,noKeyLbl,noKey,noSub},
//	{"ReadHighEndurance",m_ReadHEndurance,isSens,notChk,noKeyLbl,noKey,noSub},
//	{"WriteHighEndurance",m_WriteHEndurance,isSens,notChk,noKeyLbl,noKey,noSub},
	{NULL}
};
//@V@:EndPulldownMenu

//@V@:BeginPulldownMenu Help
static vMenu Help[] =
{
	{"About", m_About, isSens, notChk, noKeyLbl, noKey, noSub},
	{"Help index", m_HIndex, isSens, notChk, noKeyLbl, noKey, noSub},
	{NULL}
};
//@V@:EndPulldownMenu

//@V@:BeginMenu StandardMenu
static vMenu StandardMenu[] =
{
	{"&File", M_File, isSens, notUsed, notUsed, noKey, &FileMenu[0]},
	{"&Edit", M_Edit, notSens, notUsed, notUsed, noKey, &EditMenu[0]},
	{"&Device", m_Eeprom, isSens, notUsed, notUsed, noKey, &EepromMenu[0]},
	{"&Utility", m_Utility, isSens, notUsed, notUsed, noKey, &UtilityMenu[0]},
	{"&Options", m_Options, isSens, notUsed, notUsed, noKey, &OptionsMenu[0]},
	{"&?", m_Help, isSens, notUsed, notUsed, noKey, &Help[0]},
	{NULL}
};
//@V@:EndMenu

//@V@:BeginIcons
# include "icons/print.vbm"
	static vIcon printI(&print_bits[0],print_height,print_width,print_depth);
# include "icons/open.vbm"
	static vIcon openI(&open_bits[0],open_height,open_width,open_depth);
# include "icons/save.vbm"
	static vIcon saveI(&save_bits[0],save_height,save_width,save_depth);
# include "icons/rd_eep.vbm"
	static vIcon readI(&rd_eep_bits[0],rd_eep_height,rd_eep_width,rd_eep_depth);
# include "icons/wr_eep.vbm"
	static vIcon writeI(&wr_eep_bits[0],wr_eep_height,wr_eep_width,wr_eep_depth);
# include "icons/help.vbm"
	static vIcon helpI(&help_bits[0],help_height,help_width,help_depth);
# include "icons/lock.vbm"
	static vIcon lockI(&lock_bits[0],lock_height,lock_width,lock_depth);
# include "icons/reload.vbm"
	static vIcon reloadI(&reload_bits[0],reload_height,reload_width,reload_depth);
//@V@:EndIcons

//this determines only the size of the comboBox, the content will be initialized
//  within PostInit()
static char* comboList[] =
  {
    "123456789012345",   // The first item in the list
    0            // 0 terminates the list
  };


//@V@:BeginCmdPane ToolBar
static CommandObject ToolBar[] =
{
	{C_Frame,frmToolBar,0,"",NoList,CA_None,isSens,NoFrame,0,0},
	{C_IconButton,icbRead,0,"Read",&readI,CA_None,isSens,frmToolBar,0,0,  0,"Read device"},
	{C_IconButton,icbWrite,0,"Write",&writeI,CA_None,isSens,frmToolBar,icbRead,0, 0,"Write device"},
	{C_IconButton,icbLock,0,"Lock",&lockI,CA_None,isSens,frmToolBar,icbWrite,0, 0,"Write security"},
	{C_IconButton,icbOpen,0,"Open",&openI,CA_None,isSens,frmToolBar,icbLock,0, 0,"Open file"},
	{C_IconButton,icbSave,0,"Save",&saveI,CA_None,isSens,frmToolBar,icbOpen,0, 0,"Save file"},
	{C_IconButton,icbReload,0,"Reload",&reloadI,CA_None,isSens,frmToolBar,icbSave,0, 0,"Reload"},
	{C_IconButton,icbPrint,0,"Print",&printI,CA_None,isSens,frmToolBar,icbReload,0, 0,"Print"},
	{C_IconButton,icbHelp,0,"Help",&helpI,CA_None,isSens,frmToolBar,icbPrint,0, 0,"About " APPNAME},

	{C_Frame,frmToolBar2,0,"",NoList,CA_NoBorder,isSens,NoFrame,0,0},
	{C_Label, lblEEPType,0,"   Dev.Type",NoList,CA_None,isSens,frmToolBar2,0,0},

	{C_Frame,frmToolBar3,0,"",NoList,CA_NoBorder,isSens,frmToolBar2,lblEEPType,0},
	{C_ComboBox,cbxEEPType,0,"Chip Type",(void*)eepstr_vector,CA_None,isSens,frmToolBar3,0,0, 0,"Select device family"},
	{C_Label, lblEEPSubType,0," ",NoList,CA_None,isSens,frmToolBar3,cbxEEPType,0},
	{C_ComboBox,cbxEEPSubType,0,"Chip SubType",comboList,CA_None,isSens,frmToolBar3,lblEEPSubType,0, 0,"Select device type"},
	{C_EndOfList,0,0,0,0,CA_None,0,0,0}
};
//@V@:EndCmdPane

//@V@:BeginCmdPane ToolBar2
static CommandObject ToolBar2[] =
{
	{C_Label, lblComment,0,"Note",NoList,CA_None,isSens,NoFrame,0,0},
	{C_Text,txtComment,0,"",NoList,CA_None,isSens,NoFrame,0,0},
	{C_Button,btnChange,0,"Edit",NoList,CA_None,isSens,NoFrame,0,0, 0,"Edit device notes"},
	{C_EndOfList,0,0,0,0,CA_None,0,0,0}
};
//@V@:EndCmdPane

//*** 13/09/99
//#define	STATUSBAR_FORM	" 0000 0000    Size     0 Bytes     CRC  0000h      "
//#define	STATUSBAR_PRINT	" %04X %04X    Size %5ld Bytes     CRC  %04Xh     %c"
#define	STATUSBAR_FORM	"    Size     0 Bytes     CRC  0000h      "
#define	STATUSBAR_PRINT	"    Size %5ld Bytes     CRC  %04Xh     %c"

//@V@:BeginStatPane StatBar
static vStatus StatBar[] = 
{
	{APPNAME "   ", lblTestStat, CA_NoBorder, isSens, 0},
	{"                           ", lblStringID, CA_NoBorder, isSens, 0},
	{STATUSBAR_FORM, lblEEPInfo, CA_NoBorder, isSens, 0},
	{0,0,0,0,0}
};
//@V@:EndStatPane

//@V@:About Dialog Commands
#include "icons/ponyprog.vbm"
static vIcon ponyI(&pony_bits[0],pony_height,pony_width,pony_depth);

#include "icons/about.vbm"
static vIcon aboutI(&about_bits[0],about_height,about_width,about_depth);

static CommandObject AboutDlg[] = {
	{C_Text,lblAbout0,0,APPNAME " - " APPNAME_EXT "\n    Version  " VERSIONE "  " __DATE__,
			NoList,CA_NoBorder,isSens,NoFrame,icoPonyProg,0},
	{C_Frame,frmAbout1,0,"About",NoList,CA_NoBorder,isSens,NoFrame,0,lblAbout0},
	{C_Icon,icoPonyProg,0,APPNAME,&ponyI,CA_None,isSens,frmAbout1,0,0},
	{C_Text,lblAbout1,0,
		"Copyright (C) 1997-2000  by  " AUTHORNAME "\n\nE-mail: lanconel@CS.UniBO.it\nHome page at http://www.cs.unibo.it/~lanconel",
			NoList,CA_None,isSens,frmAbout1,icoPonyProg,0},
	{C_Frame,frmAboutVgui,0,"V GUI",NoList,CA_NoBorder,isSens,NoFrame,0,frmAbout1},
	{C_Icon,icoVgui,0,"V GUI",&aboutI,CA_None,isSens,frmAboutVgui,0,0},
	{C_Text,txtVgui,0,
		"This program uses the V library.\nThe V library is copyright by Bruce E.Wampler.\nYou can find it and related license at\nhttp://www.objectcentral.com",
			NoList,CA_NoBorder,isSens,frmAboutVgui,icoVgui,0},
	{C_Button,M_OK,0,
#ifdef	_WINDOWS
		" &OK ",
#else
		"  OK ",
#endif
			NoList,CA_DefaultButton,isSens,NoFrame,0,frmAboutVgui},

	{C_EndOfList,0,0,0,0,CA_None,0,0,0}
};

//==================>>> e2CmdWindow::About <<<=======================
void e2CmdWindow::About()
{
	vModalDialog about(this,"About " APPNAME);

	ItemVal dummy;
	about.AddDialogCmds(AboutDlg);
	about.ShowModalDialog("",dummy);
}


DialogCmd Notes[] =
{
#ifdef	_LINUX_
	{C_Label,lblMainMsg,0,"X",NoList,CA_MainMsg,isSens,NoFrame,0,0},
#else
	{C_Blank,lblMainMsg,0," ",NoList,CA_None,isSens,NoFrame,0,0},
#endif

	{C_Label, lblStrID,0," Chip Id",NoList,CA_None,isSens,NoFrame,0,lblMainMsg},
	{C_TextIn,txiStrID,0,"",NoList,CA_None,isSens,NoFrame,lblStrID,lblMainMsg,32},

	{C_Label, lblCommnt,0, " Note   ",NoList,CA_None,isSens,NoFrame,0,lblStrID},
	{C_TextIn,txiCommnt,0,"",NoList,CA_None,isSens,NoFrame,lblCommnt,lblStrID,80},

	{C_Button, M_Cancel, 0,
#ifdef	_WINDOWS
		" &Cancel ",
#else
		"  Cancel ",
#endif
			NoList,CA_None, isSens,NoFrame,0, lblCommnt},
	{C_Button, M_OK, 0,
#ifdef	_WINDOWS
		" &OK ",
#else
		"  OK ",
#endif
			NoList, CA_DefaultButton, isSens, NoFrame, M_Cancel, lblCommnt},

	{C_EndOfList,0,0,0,0,CA_None,0,0,0}
};


//====================>>> e2CmdWindow::e2CmdWindow <<<====================
e2CmdWindow::e2CmdWindow(char* name, int width, int height) :
		vCmdWindow(name, width, height),
		awip(0),
		editbuf_enabled(0),
		remote(0)
{
	UserDebug1(Constructor,"e2CmdWindow::e2CmdWindow(%s) Constructor\n",name)

	//Initialize "Device -> Select" menu
	int j;

	//generic
	for (j = 0; TypeMenu[j].label != NULL; j++)
	{
		if (TypeMenu[j].SubMenu == noSub)
		{
			//14/08/98
			long type = MenuIdToType(TypeMenu[j].menuId);
			TypeMenu[j].label = (char *)GetEEPTypeString(GetE2PPriType(type), GetE2PSubType(type));
			TypeMenu[j].checked = 0;
		}
	}

	//i2cMenu
	for (j = 0; i2cMenu[j].label != NULL; j++)
	{
		if (i2cMenu[j].SubMenu == noSub)
		{
			long type = MenuIdToType(i2cMenu[j].menuId);
			i2cMenu[j].label = (char *)GetEEPTypeString(GetE2PPriType(type), GetE2PSubType(type));
			i2cMenu[j].checked = 0;
		}
	}

	//spiMenu
	for (j = 0; spiMenu[j].label != NULL; j++)
	{
		if (spiMenu[j].SubMenu == noSub)
		{
			long type = MenuIdToType(spiMenu[j].menuId);
			spiMenu[j].label = (char *)GetEEPTypeString(GetE2PPriType(type), GetE2PSubType(type));
			spiMenu[j].checked = 0;
		}
	}

	//microwireMenu
	for (j = 0; microwireMenu[j].label != NULL; j++)
	{
		if (microwireMenu[j].SubMenu == noSub)
		{
			long type = MenuIdToType(microwireMenu[j].menuId);
			microwireMenu[j].label = (char *)GetEEPTypeString(GetE2PPriType(type), GetE2PSubType(type));
			microwireMenu[j].checked = 0;
		}
	}

	//avrMenu
	for (j = 0; avrMenu[j].label != NULL; j++)
	{
		if (avrMenu[j].SubMenu == noSub)
		{
			long type = MenuIdToType(avrMenu[j].menuId);
			avrMenu[j].label = (char *)GetEEPTypeString(GetE2PPriType(type), GetE2PSubType(type));
			avrMenu[j].checked = 0;
		}
	}

	//at89sMenu
	for (j = 0; at89sMenu[j].label != NULL; j++)
	{
		if (at89sMenu[j].SubMenu == noSub)
		{
			long type = MenuIdToType(at89sMenu[j].menuId);
			at89sMenu[j].label = (char *)GetEEPTypeString(GetE2PPriType(type), GetE2PSubType(type));
			at89sMenu[j].checked = 0;
		}
	}

	//picMenu
	for (j = 0; picMenu[j].label != NULL; j++)
	{
		if (picMenu[j].SubMenu == noSub)
		{
			long type = MenuIdToType(picMenu[j].menuId);
			picMenu[j].label = (char *)GetEEPTypeString(GetE2PPriType(type), GetE2PSubType(type));
			picMenu[j].checked = 0;
		}
	}

	//Clear the check in menu Edit buffer
	EditMenu[2].checked = 0;

	// The Menu Bar
	e2Menu = new vMenuPane(StandardMenu);
	AddPane(e2Menu);

	// The Command Pane
	e2CmdPane = new vCommandPane(ToolBar);
	e2CmdPane2 = new vCommandPane(ToolBar2);
#ifndef	_LINUX_
	AddPane(e2CmdPane2);
	AddPane(e2CmdPane);
#else
	AddPane(e2CmdPane);
	AddPane(e2CmdPane2);
#endif

	// The Canvas
	e2Canvas = new e2TextCanvasPane(this);
	AddPane(e2Canvas);

	// The Status Bar
	e2Status = new vStatusPane(StatBar);
	AddPane(e2Status);

//	_timer = new e2Timer(this);		// create timer
//	_timer->TimerSet(1000);		// 1 second intervals

	// Associated dialogs
	e2Dlg = new e2Dialog(this);
	e2Prg = new e2ProgressDialog(this);

	// Show Window
	ShowWindow();
	
	type_index = -1;
	//Initialize Type controls in Tool Bars
//	UpdateChipType(THEAPP->GetLastEEPType(), 0);	18/10/98
	UpdateChipType( GetE2PPriType(THEAPP->GetLastDevType()), GetE2PSubType(THEAPP->GetLastDevType()) );
	//Initialize Type in menu
//	UpdateMenuType();		*** non funziona!!!

	if (editbuf_enabled)
		e2Canvas->ShowTextCursor();
	else
		e2Canvas->HideTextCursor();


	first_line = 0;
	curIndex = 0;
}

//void e2CmdWindow::SetSubType()
//{
//}

//====================>>> e2CmdWindow::~e2CmdWindow <<<====================
e2CmdWindow::~e2CmdWindow()
{
    UserDebug(Destructor,"e2CmdWindow::~e2CmdWindow() destructor\n")

    // Now put a delete for each new in the constructor.

	delete e2Menu;
	delete e2Canvas;
	delete e2CmdPane;
	delete e2CmdPane2;
    delete e2Status;
//	_timer->TimerStop();	// end it
//	delete _timer;			// free it
	delete e2Dlg;
	delete e2Prg;
}


//====================>>> e2CmdWindow::KeyIn <<<====================
void e2CmdWindow::KeyIn(vKey keysym, unsigned int shift)
{
	switch (keysym)
	{
	case vk_Up:
	  {
		PrevLine();
		break;
	  }
	case vk_Down:
	  {
		NextLine();
		break;
	  }
	case vk_Page_Up:
	  {
		PrevPage();
		break;
	  }
	case vk_Page_Down:
	  {
		NextPage();
		break;
	  }
	case vk_Home:
	  {
		FirstPage();
		break;
	  }
	case vk_End:
	  {
		LastPage();
		break;
	  }
	case vk_Return:
	  {
		CharEdit();
		break;
	  }
//	case vk_Left:
//	case vk_Right:
	default:
	  {
		vCmdWindow::KeyIn(keysym, shift);
		break;
	  }
	}
}


int e2CmdWindow::OnError(int errno, char const *msgerr)
{
	int rv = 0;
	char msg[256];
	vNoticeDialog note(this);

	switch(errno)
	{
	case 0:
		sprintf(msg, "Device Not Responding");
		note.Notice(msg);
		break;
	case DEVICE_BADTYPE:
	{
		sprintf(msg, "Bad device, select the correct type (%d)", errno);
		retryModalDialog re(this,msg);
		rv = re.retryAction();
		break;
	}
	case DEVICE_UNKNOWN:
	{
		sprintf(msg, "Device missing or unknown device (%d)", errno);
		retryModalDialog re(this,msg);
		rv = re.retryAction();
		break;
	}
	case DEVICE_LOCKED:
	{
		sprintf(msg, "Unable to probe, bad device or device locked (%d)", errno);
		retryModalDialog re(this,msg);
		rv = re.retryAction();
		break;
	}
	case OP_ABORTED:
		note.Notice("User abort");
		break;
	case E2ERR_OPENFAILED:
		sprintf(msg, "Communication port not available (%d)", errno);
		note.Notice(msg);
		break;
	case E2ERR_ACCESSDENIED:
		sprintf(msg, "I/O access denied. You must be root to perform I/O (%d)", errno);
		note.Notice(msg);
		break;
	case E2ERR_NOTINSTALLED:
		sprintf(msg, "Hardware programmer not found (%d)", errno);
		note.Notice(msg);
		break;
	case IICERR_SDACONFLICT:
	case IICERR_SCLCONFLICT:
		sprintf(msg, "Hardware error, is the interface properly connected? (%d)", errno);
		note.Notice(msg);
		break;
	case IICERR_BUSBUSY:
		sprintf(msg, "Bus busy or hardware error (%d)", errno);
		note.Notice(msg);
		break;
	case IICERR_NOTACK:
		sprintf(msg, "Missing Acknowledge from the device (%d)", errno);
		note.Notice(msg);
		break;
	case IICERR_NOADDRACK:
	{
		sprintf(msg, "Missing device (%d)", errno);
		retryModalDialog re(this,msg);
		rv = re.retryAction();
	//	note.Notice(msg);
		break;
	}
	case IICERR_TIMEOUT:
		sprintf(msg, "Bus timeout (%d)", errno);
		note.Notice(msg);
		break;
	case IICERR_STOP:
		sprintf(msg, "Stop condition error (bad timing?) (%d)", errno);
		note.Notice(msg);
		break;
	case E2ERR_WRITEFAILED:
		sprintf(msg, "Write error (%d)", errno);
		note.Notice(msg);
		break;
	default:
		if (msgerr)
		{
			strncpy(msg, msgerr, 255);
			msg[255] = '\0';
		}
		else
			sprintf(msg, "Error n.%d", errno);
		note.Notice(msg);
		break;
	}

	return rv;
}

//====================>>> e2CmdWindow::WindowCommand <<<====================
void e2CmdWindow::WindowCommand(ItemVal id, ItemVal val, CmdType cType)
{
	// Default: route menu and toolbar commands here

	UserDebug1(CmdEvents,"e2CmdWindow:WindowCommand(%d)\n",id)

	switch (id)
	{
	//@V@:Case M_New
	case M_New:
		if (THEAPP->IsAppReady())
		{
			theApp->NewAppWin(0, "",
					theApp->DefaultWidth(), theApp->DefaultHeight(), 0);
		}
		break;

	//@V@:Case M_Open
	case M_Open:
	case icbOpen:
		if (THEAPP->IsAppReady())
		{
			CmdOpen();
		}
		break;

	//Load last file
	case m_File1:
		if (THEAPP->IsAppReady())
		{
			CmdLastFile1();
		}
		break;

	//Load previous file
	case m_File2:
		if (THEAPP->IsAppReady())
		{
			CmdLastFile2();
		}
		break;

	//reload previous file and last file
	case icbReload:
		if (THEAPP->IsAppReady())
		{
		//	CmdReload(val, cType);
			CmdReload();
		}
		break;

	//@V@:Case M_Save
	case M_Save:
	case icbSave:
		if (THEAPP->IsAppReady())
		{
			CmdSave();
		}
		break;

	//@V@:Case M_SaveAs
	case M_SaveAs:
		if (THEAPP->IsAppReady())
		{
			SaveFile(1);
		}
		break;

#ifdef	vDEBUG
	case M_SetDebug:
	  {
		vDebugDialog debug(this);
		debug.SetDebug();
		break;
	  }
#endif

	//@V@:Case icbPrint
	case M_Print:
	case icbPrint:
		if (THEAPP->IsAppReady())
		{
			CmdPrint();
		}
		break;

	//@V@:Case M_Close
	case M_Close:
		{
			theApp->CloseAppWin(this);
		}
		break;

	//@V@:Case M_Exit
	case M_Exit:
		{
			theApp->Exit();
		}
		break;

	//@V@:Case M_Cut
	case M_Cut:
		if (THEAPP->IsAppReady())
		{
			vNoticeDialog note(this);
			note.Notice("Under construction");
		}
		break;

	//@V@:Case M_Copy
	case M_Copy:
		if (THEAPP->IsAppReady())
		{
			vNoticeDialog note(this);
			note.Notice("Under construction");
		}
		break;

	//@V@:Case M_Paste
	case M_Paste:
		if (THEAPP->IsAppReady())
		{
			vNoticeDialog note(this);
			note.Notice("Under construction");
		}
		break;

	case m_About:
	case icbHelp:
		if (THEAPP->IsAppReady())
		{
			About();
		}
		break;

	case m_HIndex:
		if (THEAPP->IsAppReady())
		{
			CmdHelp();
		}
		break;

	//@V@:Case m_Setup
	case m_Setup:
		if (THEAPP->IsAppReady())
		{
			if (!e2Dlg->IsDisplayed())
				e2Dlg->ShowDialog("I/O port setup");
		}
		break;

	//@V@:Case m_Calibration
	case m_Calibration:
		if (THEAPP->IsAppReady())
		{
			THEAPP->SetAppBusy();
			CmdCalibration();
			THEAPP->SetAppReady();
		}
		break;

	case m_Read:
	case icbRead:
		if (THEAPP->IsAppReady())
		{
			THEAPP->SetAppBusy();
			CmdRead();
			THEAPP->SetAppReady();
		}
		break;

	case m_Write:
	case icbWrite:
		if (THEAPP->IsAppReady())
		{
			THEAPP->SetAppBusy();
			CmdWrite();
			THEAPP->SetAppReady();
		}
		break;

	case m_Verify:
		if (THEAPP->IsAppReady())
		{
			THEAPP->SetAppBusy();
			CmdVerify();
			THEAPP->SetAppReady();
		}
		break;
			

	case m_Erase:
		if (THEAPP->IsAppReady())
		{
			THEAPP->SetAppBusy();
			CmdErase();
			THEAPP->SetAppReady();
		}
		break;

	case m_Info:
		if (THEAPP->IsAppReady())
		{
			THEAPP->SetAppBusy();
			CmdGetInfo();
			THEAPP->SetAppReady();
		}
		break;

	case m_SpecBits:
		if (THEAPP->IsAppReady())
		{
			SpecialBits();
		}
		break;

	case m_Reset:
		if (THEAPP->IsAppReady())
		{
			CmdReset();
		}
		break;
 
	case m_DoubleSize:
		if (THEAPP->IsAppReady())
		{
		//	CmdDoubleSize(val, cType);
			CmdDoubleSize();
		}
		break;

	case m_ClearBuf:
		if (THEAPP->IsAppReady())
		{
			CmdClearBuf();
		}
		break;

	case m_FillBuf:
		if (THEAPP->IsAppReady())
		{
			CmdFillBuf();
		}
		break;

	case m_ByteSwap:
		if (THEAPP->IsAppReady())
		{
			CmdByteSwap();
		}
		break;

	case m_ReadSecurity:
		if (THEAPP->IsAppReady())
		{
			CmdReadSecurity();
		}
		break;

	case icbLock:
	case m_WriteSecurity:
		if (THEAPP->IsAppReady())
		{
			CmdWriteSecurity();
		}
		break;

	case m_WriteHEndurance:
		if (THEAPP->IsAppReady())
		{
			CmdWriteSpecial();
		}
		break;

	case m_EditBuf:
		{
			editbuf_enabled = !editbuf_enabled;
			SetValue(m_EditBuf, editbuf_enabled, Checked);
			Draw();
		}
		break;

	case m_Note:
	case btnChange:
		if (THEAPP->IsAppReady())
		{
			CmdEditNote();
		}
		break;

	case m_Remote:
		if (THEAPP->IsAppReady())
		{
			THEAPP->SetAppBusy();
			CmdRemoteMode();
			THEAPP->SetAppReady();
		}
		break;

	//AutoTag
    //List of case menu Id
	case m_24XX:
	case m_2402:
	case m_2404:
	case m_2408:
	case m_2416:
	case m_24325:
	case m_24645:
	case m_2432:
	case m_2464:
	case m_24128:
	case m_24256:
	case m_24512:
	case m_9306:
	case m_9346:
	case m_9356:
	case m_9366:
	case m_9376:
	case m_9386:
	case m_at90sXXXX:
	case m_at90s1200:
	case m_at90s2313:
	case m_at90s4414:
	case m_at90s8515:
	case m_atmega603:
	case m_atmega103:
	case m_at90s2323:
	case m_at90s2333:
	case m_at90s2343:
	case m_at90s4433:
	case m_at90s4434:
	case m_at90s8534:
	case m_at90s8535:
	case m_attiny12:
	case m_attiny22:
	case m_at89s8252:
	case m_at89s53:
	case m_pic1684:
	case m_25010:
	case m_25020:
	case m_25040:
	case m_25080:
	case m_25160:
	case m_25320:
	case m_25640:
	case m_25128:
	case m_25256:
	case m_sde2506:
		if (THEAPP->IsAppReady())
		{
		//	CmdSelectDevice(id);
			CmdSelectDevice( MenuIdToType(id) );
		}
		break;

	case cbxEEPType:
		if (THEAPP->IsAppReady())
		{
			CmdSetDeviceType(val);
		}
		break;

	case cbxEEPSubType:
		if (THEAPP->IsAppReady())
		{
			CmdSetDeviceSubType(val);
		}
		break;

	case idAskToSave:
		if ( IsBufChanged() )
		{
			vYNReplyDialog yn(this);
			char str[128];
			sprintf(str, "Buffer \"%s\" changed. Save it before to close?", GetFileName());
			if ( yn.AskYN(str) > 0 )
			{
				SaveFile();
			}
		}
		break;

	case pbrProgress:
		{
			e2Prg->UpdateDialog(val);
		}
		break;

	case idCloseAllDialog:
		{
			e2Prg->CloseDialog();
			e2Dlg->CloseDialog();
		}
		break;

	case idEnableToolBar:
		{
			if (val)
			{
				SetValue(cbxEEPType, 1, Sensitive);
				SetValue(cbxEEPSubType, 1, Sensitive);
				SetValue(icbRead, 1, Sensitive);
				SetValue(icbWrite, 1, Sensitive);
				SetValue(icbLock, 1, Sensitive);
				SetValue(icbOpen, 1, Sensitive);
				SetValue(icbSave, 1, Sensitive);
				SetValue(icbReload, 1, Sensitive);
				SetValue(icbPrint, 1, Sensitive);
				SetValue(icbHelp, 1, Sensitive);
			}
			else
			{
				SetValue(cbxEEPType, 0, Sensitive);
				SetValue(cbxEEPSubType, 0, Sensitive);
				SetValue(icbRead, 0, Sensitive);
				SetValue(icbWrite, 0, Sensitive);
				SetValue(icbLock, 0, Sensitive);
				SetValue(icbOpen, 0, Sensitive);
				SetValue(icbSave, 0, Sensitive);
				SetValue(icbReload, 0, Sensitive);
				SetValue(icbPrint, 0, Sensitive);
				SetValue(icbHelp, 0, Sensitive);
			}
		}
		break;

	default:		// route unhandled commands up
		{
			vCmdWindow::WindowCommand(id, val, cType);
			break;
		}
    }
}

HIDDEN int FileExist(char const *name);
HIDDEN int CmpExtension(char const *name, char const *ext);

//====================>>> e2CmdWindow::CmdSave <<<====================
int e2CmdWindow::CmdSave()
{
	int result = OK;

	if (awip->IsBufferValid())
		SaveFile();
	else
	{
		result = CMD_NOTHINGTOSAVE;
		if (!remote)
		{
			vNoticeDialog note(this);
			note.Notice("Nothing to save");
		}
	}

	return result;
}

//====================>>> e2CmdWindow::CmdLastFile1 <<<====================
int e2CmdWindow::CmdLastFile1()
{
	int result = OK;

	if (!remote)
	{
		if ( IsBufChanged() && awip->IsBufferValid() )
		{
			vYNReplyDialog yn(this);
			if ( yn.AskYN("Buffer changed. Save it before to close?") > 0 )
			{
				SaveFile();
			}
		}
	}
	OpenFile(THEAPP->GetLastFile());
	UpdateChipType();
	UpdateMenuType();
	UpdateStatusBar();

	return result;
}

//====================>>> e2CmdWindow::CmdLastFile2 <<<====================
int e2CmdWindow::CmdLastFile2()
{
	int result = OK;

	if (!remote)
	{
		if ( IsBufChanged() && awip->IsBufferValid() )
		{
			vYNReplyDialog yn(this);
			if ( yn.AskYN("Buffer changed. Save it before to close?") > 0 )
			{
				SaveFile();
			}
		}
	}
	OpenFile(THEAPP->GetPrevFile());
	UpdateChipType();
	UpdateMenuType();
	UpdateStatusBar();

	return result;
}

//====================>>> e2CmdWindow::CmdReload <<<====================
int e2CmdWindow::CmdReload()
{
	int result = OK;

	//solo nel caso in cui il penultimo file era un .hex e l'ultimo
	//  un .eep (caso dell'AVR con caricamento Flash+eeprom), ricarica
	//  entrambi i file in sequenza, in caso contrario ricarica solo
	//  l'ultimo.
	if ( THEAPP->GetPrevFile() && FileExist(THEAPP->GetPrevFile()) 
		 && CmpExtension(THEAPP->GetLastFile(), ".eep") == 0
		 && CmpExtension(THEAPP->GetPrevFile(), ".hex") == 0 )
	{
		CmdLastFile2();

		//A questo punto il last e` diventato Prev!!
		//Now Last became Prev
		if (THEAPP->GetPrevFile())
		{
			CmdLastFile2();
		}
	}
	else
	if (THEAPP->GetLastFile())
	{
		CmdLastFile1();
	}
	else
	{
		result = CMD_NOTHINGTOLOAD;
		if (!remote)
		{
			vNoticeDialog note(this);
			note.Notice("Nothing to load");
		}
	}

	return result;
}

//====================>>> e2CmdWindow::CmdPrint <<<====================
int e2CmdWindow::CmdPrint()
{
	if (awip->IsBufferValid())
		Print();
	else
	{
		vNoticeDialog note(this);
		note.Notice("Nothing to print");
	}

	return OK;
}

//====================>>> e2CmdWindow::CmdHelp <<<====================
int e2CmdWindow::CmdHelp()
{
#ifdef	_WINDOWS
	ShellExecute(NULL, "open", THEAPP->GetHelpFile(), NULL, NULL, SW_SHOWNORMAL);
#endif
#ifdef	_LINUX_
	char str[256];
	sprintf(str, "netscape %s &", THEAPP->GetHelpFile());
	system(str);
#endif

	return OK;
}

//====================>>> e2CmdWindow::CmdCalibration <<<====================
int e2CmdWindow::CmdCalibration()
{
	vYNReplyDialog yn(this);
//	if ( yn.AskYN("I2C Bus calibration.\nInsert a well working I2C Bus EEPROM (i.e. 24C16), then press YES") > 0 )
	if ( yn.AskYN("Bus timing calibration.\nBe sure there're no application running other than " APPNAME "\n(the CPU and hard disk have to be idle)\nThe calibration may take a couple of seconds.\nDo you want to run calibration now?") > 0 )
	{
		vNoticeDialog note(this);
		int err = THEAPP->Calibration();
		if (err == OK)
		{
			note.Notice("Calibration OK");
			UpdateStatusBar();
//			THEAPP->SetParDelayLoop( THEAPP->GetDelayLoop() );
		}
		else
		{
			char str[64];
			sprintf(str, "Calibration failed (%d)", err);
			note.Notice(str);
		}
	}

	return OK;
}

//====================>>> e2CmdWindow::CmdRead <<<====================
int e2CmdWindow::CmdRead()
{
	THEAPP->ClearIgnoreFlag();

	int result;
	int rval;
	int retry_flag = 1;

	while (retry_flag)
	{
		result = OK;

		retry_flag = 0;

		if (!e2Prg->IsDisplayed())
			e2Prg->UpdateDialog(0, "Reading...");

	//	vCmdWindow::SetTitle(DEF_TITLE);
		awip->SetFileName(0);
		SetTitle();

		rval = awip->Read();
		e2Prg->CloseDialog();

	  	if ( rval > 0 )
	  	{
	 	 	first_line = 0;
			curIndex = 0;
			Draw();

			char const *sp;
			sp = GetEEPTypeString(awip->GetEEPPriType(), awip->GetEEPSubType());
			UpdateStrFromStr(sp, "");
			awip->RecalcCRC();
			UpdateStatusBar();

			char str[128];
			int rlv = awip->BankRollOverDetect();
			if (rlv == 0)
			{
				sprintf(str, "Read successful\nDevice Size: %ld Bytes\nCan't know bank roll-over without write", GetDevSize());
			}
			else
			if (rlv < 0)	//Errore I2C nel rilevamento del roll-over
			{
				sprintf(str, "Read successful\nDevice Size: %ld Bytes\nBank roll-over detect failed", GetDevSize());
				result = CMD_ROLLOVERFAILED;
			}
			else
			{
				sprintf(str, "Read successful\nDevice Size: %ld Bytes\nBank roll-over capability: %s", GetDevSize(), rlv == 1 ? "Yes" : "No ");
			}

			if (!remote)
			{
				vNoticeDialog note(this);
				note.Notice(str);
			}
		}
		else
		{
	 	 	first_line = 0;
			curIndex = 0;
			Draw();

			UserDebug(UserApp1, "CmdWindow->Read -- Error\n");

			result = rval;

			if (!remote)
			{
				rval = OnError(rval);
				if (rval == 0)	//Abort
				{
					retry_flag = 0;
					THEAPP->ClearIgnoreFlag();
				}
				if (rval == 1)	//Retry
				{
					retry_flag = 1;
					THEAPP->ClearIgnoreFlag();
				}
				else
				if (rval == 2)	//Ignore
				{
					retry_flag = 1;
					THEAPP->SetIgnoreFlag();
				}
			}
		}
	} //while (retry_flag)

	return result;
}


//====================>>> e2CmdWindow::CmdWrite <<<====================
int e2CmdWindow::CmdWrite()
{
	int result = OK;

	if ( !awip->IsBufferValid() )
	{
		if (!remote)
		{
			vNoticeDialog note(this);
			note.Notice("Nothing to write");
		}
		result = CMD_NOTHINGTOWRITE;
	}
	else
	{
		vYNReplyDialog yn(this);

		if ( remote || yn.AskYN("Are you sure to write the device?") > 0 )
		{
			int rval;
			int retry_flag = 1;

			while (retry_flag)
			{
				result = OK;

				retry_flag = 0;

				if (!e2Prg->IsDisplayed())
					e2Prg->UpdateDialog(0, "Writing...");

	  			if ( (rval = awip->Write(TRUE)) > 0 )
	  			{
					UserDebug(UserApp2, "CmdWindow->Write 1\n");

					vNoticeDialog note(this);

					UserDebug(UserApp2, "CmdWindow->Write 2\n");

					e2Prg->UpdateDialog(0, "Verifing...");

					UserDebug(UserApp2, "CmdWindow->Write 3\n");

					rval = awip->Verify(FALSE);
					e2Prg->CloseDialog();

					if ( rval > 0 )	//23/10/1999
					{
						//Aggiunto il 01/10/98
	 					first_line = 0;
						curIndex = 0;
						Draw();

						if (GetDevSize() == 0)
						{
							char const *sp;
							sp = GetEEPTypeString(awip->GetEEPPriType(), awip->GetEEPSubType());
							UpdateStrFromStr(sp);
						}
						awip->RecalcCRC();
						//---

						UpdateStatusBar();
						if (!remote)
							note.Notice("Write successful");
					}
					else
					if (rval == 0)
					{
						if (!remote)
							note.Notice("Write failed");
						result = CMD_WRITEFAILED;
					}
					else
					{
						if (!remote)
							OnError(rval, "Write Failed");
						result = rval;
					}
				} // if ( (rval = ...
				else
				{
					e2Prg->CloseDialog();
					THEAPP->CheckEvents();

					result = rval;

					if (!remote)
					{
						rval = OnError(rval, "Write Failed");
						if (rval == 0)	//Abort
						{
							retry_flag = 0;
							THEAPP->ClearIgnoreFlag();
						}
						if (rval == 1)	//Retry
						{
							retry_flag = 1;
							THEAPP->ClearIgnoreFlag();
						}
						else
						if (rval == 2)	//Ignore
						{
							retry_flag = 1;
							THEAPP->SetIgnoreFlag();
						}
					} // if (!remote)
				}
			} // while (retry_flag)

			e2Prg->CloseDialog();
		} // if ( yn.AskYN(...
	} //else

	return result;
}

//====================>>> e2CmdWindow::CmdVerify <<<====================
int e2CmdWindow::CmdVerify()
{
	int result = OK;

	if ( !awip->IsBufferValid() )
	{
		if (!remote)
		{
			vNoticeDialog note(this);
			note.Notice("Nothing to verify");
		}
		result = CMD_NOTHINGTOVERIFY;
	}
	else
	{
		if (!e2Prg->IsDisplayed())
			e2Prg->UpdateDialog(0, "Verifing...");

		vNoticeDialog note(this);

		int rval = awip->Verify();
		e2Prg->CloseDialog();

		if (rval < 0)
		{
			result = rval;
			if (!remote)
				OnError(rval, "Cannot verify, device missing or bad device");
		}
		else
		if (rval == 0)
		{
			result = CMD_VERIFYFAILED;
			if (!remote)
				note.Notice("Verify Failed");
		}
		else
		{
			result = OK;
			if (!remote)
				note.Notice("Verify successful");
		}
	}

	return result;
}

//====================>>> e2CmdWindow::CmdErase <<<====================
int e2CmdWindow::CmdErase()
{
	int result;

	vNoticeDialog note(this);
	result = awip->Erase();
	if (result == OK )
		note.Notice("Erase successful");
	else
		note.Notice("Erase failed");

	return result;
}

//====================>>> e2CmdWindow::CmdGetInfo <<<====================
int e2CmdWindow::CmdGetInfo()
{
	int rlv = awip->GetBankRollOver();
	if (rlv == 0)
		rlv = awip->BankRollOverDetect(1);

	int secstart = -1, seclen = -1, hend = -1;
//	awip->SecurityRead(secstart, seclen);
	awip->HighEnduranceRead(hend);

	infoModalDialog info(this, rlv, awip->GetCRC(), GetDevSize(), secstart, seclen, hend);
	info.infoAction();

	return OK;
}

int e2CmdWindow::CmdReset()
{
	vNoticeDialog note(this);
	awip->Reset();
	note.Notice("Device resetted");

	return OK;
}

//====================>>> e2CmdWindow::CmdDoubleSize <<<====================
int e2CmdWindow::CmdDoubleSize()
{
	vNoticeDialog note(this);

	if ( !awip->IsBufferValid() )
	{
		note.Notice("Buffer empty");
	}
	else
	{
		// Double the size
		long new_type = GetEEPTypeFromSize(awip->GetEEPPriType(), awip->GetSize() * 2);
		if (new_type > 0)
		{
			awip->DoubleSize();
			CmdSelectDevice(new_type);
		}
		else
		{
			note.Notice("Operation failed");
		}
	}

	return OK;
}

//====================>>> e2CmdWindow::CmdSetDeviceType <<<====================
int e2CmdWindow::CmdSetDeviceType(ItemVal val)
{
	awip->SetEEProm(eeptype_vector[val]);
	UpdateMenuType();
	char const *sp = GetEEPTypeString(awip->GetEEPPriType(), awip->GetEEPSubType());
	UpdateStrFromStr(sp);
	SetChipSubType(awip->GetEEPPriType());
	first_line = 0;
	curIndex = 0;
	Draw();
	awip->RecalcCRC();	//??? 08/02/1998 riguardare
	UpdateStatusBar();

	//Memorizza in memoria e nel file .INI
	THEAPP->SetLastDevType( BuildE2PType(awip->GetEEPPriType(), awip->GetEEPSubType()) );

	return OK;
}

//====================>>> e2CmdWindow::CmdSetDeviceSubType <<<====================
int e2CmdWindow::CmdSetDeviceSubType(ItemVal val)
{
	long *vp = GetEEPSubTypeVector(awip->GetEEPPriType());
	long newtype = vp[val];
	awip->SetEEProm(GetE2PPriType(newtype), GetE2PSubType(newtype));
	UpdateMenuType();
	char const *sp = GetEEPTypeString(awip->GetEEPPriType(), awip->GetEEPSubType());
	UpdateStrFromStr(sp);
	first_line = 0;
	curIndex = 0;
	Draw();
	awip->RecalcCRC();	//??? 08/02/1998 riguardare
	UpdateStatusBar();

	//Store in the .INI file
	THEAPP->SetLastDevType( BuildE2PType(awip->GetEEPPriType(), awip->GetEEPSubType()) );

	return OK;
}

//====================>>> e2CmdWindow::CmdOpen <<<====================
int e2CmdWindow::CmdOpen()
{
	if ( IsBufChanged() && awip->IsBufferValid() )
	{
		vYNReplyDialog yn(this);
		if ( yn.AskYN("Buffer changed. Save it before to close?") > 0 )
		{
			SaveFile();
		}
	}

	OpenFile();
	UpdateChipType();
	UpdateMenuType();
	UpdateStatusBar();

	return OK;
}

//====================>>> e2CmdWindow::CmdClearBuf <<<====================
int e2CmdWindow::CmdClearBuf()
{
	awip->FillBuffer();
	Draw();
	UpdateStatusBar();

	return OK;
}

//====================>>> e2CmdWindow::CmdFillBuf <<<====================
int e2CmdWindow::CmdFillBuf()
{
	static long from = 0, to = 0xFFFF;
	static int val = 0xFF;

	FillDialog e2Fill(this, from, to, val);
	if ( e2Fill.fillAction("Insert parameters") )
	{
	//	char str[128];
	//	sprintf(str, "%04lX %04lX %02X", dlg.GetFrom(), dlg.GetTo(), dlg.GetValue());

		vNoticeDialog note(this);
	//	note.Notice(str);

		if (e2Fill.GetFrom() <= e2Fill.GetTo())
		{
			from = e2Fill.GetFrom();
			to = e2Fill.GetTo();
			val = e2Fill.GetValue();

			awip->FillBuffer(from, val, to - from + 1);
			Draw();
			UpdateStatusBar();
		}
		else
		{
			note.Notice("Bad parameters");
		}
	}

	return OK;
}

//====================>>> e2CmdWindow::SpecialBits <<<====================
int e2CmdWindow::SpecialBits(int readonly)
{
	int rval;
	int lock, fuse;

	lock = awip->GetLockBits();
	fuse = awip->GetFuseBits();

	fuseModalDialog e2Fuse(this);
	rval = e2Fuse.fuseAction(" ", BuildE2PType(awip->GetEEPPriType(), awip->GetEEPSubType()), lock, fuse, readonly);
	if (rval != 0)	//OK
	{
		awip->SetLockBits(lock);
		awip->SetFuseBits(fuse);

		if (rval == 2)	//Program
		{
			CmdWriteSecurity();
		}
	}

	return OK;
}

//====================>>> e2CmdWindow::CmdReadSecurity <<<====================
int e2CmdWindow::CmdReadSecurity()
{
	int result;

	result = CmdReadLock();
	if (result == OK)
		result = CmdReadSpecial();

	return result;
}

//====================>>> e2CmdWindow::CmdWriteSecurity <<<====================
int e2CmdWindow::CmdWriteSecurity()
{
	int result;

	result = CmdWriteSpecial();
	if (result == OK)
	{
		Wait w;
		w.WaitMsec(500);
		result = CmdWriteLock();
	}

	return result;
}

//====================>>> e2CmdWindow::CmdWriteLock <<<====================
int e2CmdWindow::CmdWriteLock()
{
	int result = OK;

	vNoticeDialog note(this);
/**
	long type = BuildE2PType( awip->GetEEPPriType(), awip->GetEEPSubType() );
	if (type == E2464)		//implementazione per le Microchip 24C65
	{
		vReplyDialog rp(this);      // instantiate
		char r[100];                // a buffer for reply

		rp.Reply("Enter the first block      ",r,99);
		if (*r)
		{
			int sb, nb;

			sb = atoi(r);

			rp.Reply("Enter the number of blocks ",r,99);
			if (*r)
			{
				if ((nb = atoi(r)) != 0)
				{
					char str[64];
					sprintf(str, "Security bits write succesful (%d,%d)", sb, nb);

					int err = awip->SecurityWrite( ((sb << 4) & 0xF0) | (nb & 0x0F) );
					if (err)
					{
						if (err == IICERR_NOADDRACK)
							note.Notice("Device Not Responding");
						else
							note.Notice("Security bits write error");
					}
					else
					{
						int val;
						awip->SecurityRead(val);
						if ( ((val >> 4) & 0x0F) != sb || (val & 0xF) != nb)
							note.Notice("Security bits write failed");
						else
							note.Notice(str);
					}
				}
				else
					note.Notice("Error");
			}
		}
	}
	else
**/
	{
		int rval;
		int retry_flag = 1;

		while (retry_flag)
		{
			result = OK;

			retry_flag = 0;

			if (!e2Prg->IsDisplayed())
				e2Prg->UpdateDialog(0, "Writing security bits...");

	  		if ( (rval = awip->SecurityWrite()) == OK )
	  		{
				e2Prg->CloseDialog();

			//	if (!remote)
			//		note.Notice("Security bits write successful");

			} // if ( (rval = ...
			else
			{
				e2Prg->CloseDialog();
				THEAPP->CheckEvents();

				result = rval;

				if (!remote)
				{
					rval = OnError(rval, "Security bits write failed");
					if (rval == 0)	//Abort
					{
						retry_flag = 0;
						THEAPP->ClearIgnoreFlag();
					}
					if (rval == 1)	//Retry
					{
						retry_flag = 1;
						THEAPP->ClearIgnoreFlag();
					}
					else
					if (rval == 2)	//Ignore
					{
						retry_flag = 1;
						THEAPP->SetIgnoreFlag();
					}
				} // if (!remote)
			} // else
		} // while (retry_flag)
	}

	return result;
}

//====================>>> e2CmdWindow::CmdReadLock <<<====================
int e2CmdWindow::CmdReadLock()
{
	int result = OK, bits;

	int rval;
	int retry_flag = 1;

//	long type = BuildE2PType( awip->GetEEPPriType(), awip->GetEEPSubType() );

	while (retry_flag)
	{
		result = OK;

		retry_flag = 0;

		if (!e2Prg->IsDisplayed())
			e2Prg->UpdateDialog(0, "Reading security bits...");

		rval = awip->SecurityRead(bits);

	  	if ( rval == OK )
	  	{
			e2Prg->CloseDialog();

		//	SpecialBits();
		} // if ( (rval = ...
		else
		{
			e2Prg->CloseDialog();
			THEAPP->CheckEvents();

			result = rval;

			if (!remote)
			{
				rval = OnError(rval, "Security bits read failed");
				if (rval == 0)	//Abort
				{
					retry_flag = 0;
					THEAPP->ClearIgnoreFlag();
				}
				if (rval == 1)	//Retry
				{
					retry_flag = 1;
					THEAPP->ClearIgnoreFlag();
				}
				else
				if (rval == 2)	//Ignore
				{
					retry_flag = 1;
					THEAPP->SetIgnoreFlag();
				}
			} // if (!remote)
		} // else
	} // while (retry_flag)

	return result;
}

//====================>>> e2CmdWindow::CmdReadSpecial <<<====================
int e2CmdWindow::CmdReadSpecial()
{
	int result = OK, bits;

	int rval;
	int retry_flag = 1;

	long type = BuildE2PType( awip->GetEEPPriType(), awip->GetEEPSubType() );

	while (retry_flag)
	{
		result = OK;

		retry_flag = 0;

		if (!e2Prg->IsDisplayed())
			e2Prg->UpdateDialog(0, "Reading special bits...");

		if (type == E2464)
			rval = awip->HighEnduranceRead(bits);
		else
			rval = awip->FusesRead(bits);

	  	if ( rval == OK )
	  	{
			e2Prg->CloseDialog();

			SpecialBits(1);
		} // if ( (rval = ...
		else
		{
			e2Prg->CloseDialog();
			THEAPP->CheckEvents();

			result = rval;

			if (!remote)
			{
				rval = OnError(rval, "Special bits read failed");
				if (rval == 0)	//Abort
				{
					retry_flag = 0;
					THEAPP->ClearIgnoreFlag();
				}
				if (rval == 1)	//Retry
				{
					retry_flag = 1;
					THEAPP->ClearIgnoreFlag();
				}
				else
				if (rval == 2)	//Ignore
				{
					retry_flag = 1;
					THEAPP->SetIgnoreFlag();
				}
			} // if (!remote)
		} // else
	} // while (retry_flag)

	return result;
}

//====================>>> e2CmdWindow::CmdWriteSpecial <<<====================
int e2CmdWindow::CmdWriteSpecial()
{
	int result = OK;

	vNoticeDialog note(this);

	long type = BuildE2PType( awip->GetEEPPriType(), awip->GetEEPSubType() );
	/**
	if (type == E2464)		//Microchip 24C65 high endurance block
	{
		vReplyDialog rp(this);      // instantiate
		char r[100];                // a buffer for reply

		rp.Reply("Enter the high endurance block ",r,99);
		if (*r)
		{
			int a, err;

			a = atoi(r);
			if ( (err = awip->HighEnduranceWrite(a)) )
			{
				if (err == IICERR_NOADDRACK)
					note.Notice("Device Not Responding");
				else
					note.Notice("High endurance block write error");
			}
			else
			{
				int hend = -1;
				awip->HighEnduranceRead(hend);
				if (hend != a)
					note.Notice("High enduranche block write failed");
				else
				{
					result = OK;
					note.Notice("High endurance block write succesful");
				}
			}
		}
	}
	else
	**/
	{
		int rval;
		int retry_flag = 1;

		while (retry_flag)
		{
			result = OK;

			retry_flag = 0;

			if (!e2Prg->IsDisplayed())
				e2Prg->UpdateDialog(0, "Writing special bits...");

			if (type == E2464)
				rval = awip->HighEnduranceWrite();
			else
				rval = awip->FusesWrite();

	  		if ( rval == OK )
	  		{
				e2Prg->CloseDialog();

			//	if (!remote)
			//		note.Notice("Special write successful");
			} // if ( (rval = ...
			else
			{
				e2Prg->CloseDialog();
				THEAPP->CheckEvents();

				result = rval;

				if (!remote)
				{
					rval = OnError(rval, "Special bits write failed");
					if (rval == 0)	//Abort
					{
						retry_flag = 0;
						THEAPP->ClearIgnoreFlag();
					}
					if (rval == 1)	//Retry
					{
						retry_flag = 1;
						THEAPP->ClearIgnoreFlag();
					}
					else
					if (rval == 2)	//Ignore
					{
						retry_flag = 1;
						THEAPP->SetIgnoreFlag();
					}
				} // if (!remote)
			} // else
		} // while (retry_flag)
	}

	return result;
}

//====================>>> e2CmdWindow::CmdByteSwap <<<====================
int e2CmdWindow::CmdByteSwap()
{
	int result = OK;

	if ( !awip->IsBufferValid() )
	{
		result = CMD_BUFFEREMPTY;
		if (!remote)
		{
			vNoticeDialog note(this);
			note.Notice("Buffer empty");
		}
	}
	else
	{
		awip->SwapBytes();
		Draw();
		UpdateStatusBar();
	}

	return result;
}

//====================>>> e2CmdWindow::CmdEditNote <<<====================
int e2CmdWindow::CmdEditNote()
{
	char str1[STRINGID_SIZE+1];
	char str2[COMMENT_SIZE+1];
	notesModalDialog notes(this,awip->GetStringID(),awip->GetComment());
	int rv;

	rv = notes.notesAction();
	notes.GetTextIn(txiStrID, str1, STRINGID_SIZE+1);
	notes.GetTextIn(txiCommnt, str2, COMMENT_SIZE+1);

	if (rv)
	{
		UpdateStrFromStr(str1, str2);
		UpdateStatusBar();
	}

	return OK;
}

//====================>>> e2CmdWindow::CmdSelectDevice <<<====================
int e2CmdWindow::CmdSelectDevice(long new_type)
{
//	long new_type = MenuIdToType(id);
	awip->SetEEProm( GetE2PPriType(new_type), GetE2PSubType(new_type) );
	UpdateMenuType(new_type);
	UpdateChipType(awip->GetEEPPriType(), awip->GetEEPSubType());
	char const *sp = GetEEPTypeString(awip->GetEEPPriType(), awip->GetEEPSubType());
	UpdateStrFromStr(sp);
	first_line = 0;
	curIndex = 0;
	Draw();
	awip->RecalcCRC();	//??? 08/02/1998 riguardare
	UpdateStatusBar();

	//Memorizza in memoria e nel file .INI
	THEAPP->SetLastDevType( BuildE2PType(awip->GetEEPPriType(), awip->GetEEPSubType()) );

	return OK;
}

//==================>>> e2CmdWindow::CmdRemoteMode <<<=======================
void e2CmdWindow::CmdRemoteMode()
{
	remote = 1;

	e2Prg->UpdateDialog(0, "Accepting commands...");

	SocketServer srv(this);

	if ( srv.UDPMainLoop() != OK)
		e2Prg->CloseDialog();

	remote = 0;
}

//===================>>> e2CmdWindow::GetDevSize <<<=========================
long e2CmdWindow::GetDevSize() const
{
	return awip->GetSize() == AUTOSIZE_ID ? 0 : awip->GetSize();
}

//===================>>> e2CmdWindow::IsBufChanged <<<=========================
int e2CmdWindow::IsBufChanged() const
{
	return awip->IsBufChanged();
}

//==================>>> e2CmdWindow::UpdateStatusBar <<<=======================
void e2CmdWindow::UpdateStatusBar()
{
  	char buf[128];
	//*** 13/09/99
//	sprintf(buf,STATUSBAR_PRINT, awip->GetEEPPriType(), awip->GetEEPSubType(), GetDevSize(), awip->GetCRC(), awip->IsBufChanged() ? '*' : ' ');
	sprintf(buf,STATUSBAR_PRINT, GetDevSize(), awip->GetCRC(), awip->IsBufChanged() ? '*' : ' ');
	SetString(lblEEPInfo, buf);
	SetString(lblStringID, awip == 0 ? (char *)" " : awip->GetStringID());
}

//==================>>> e2CmdWindow::SetChipSubType <<<=======================
void e2CmdWindow::SetChipSubType(int pritype, int subtype)
{
	long type = BuildE2PType(pritype, subtype);

	//11 - indice pulsante all'interno della toolbar
	//ATTENZIONE! cambia ogni volta che si sposta il gadget!

	//Look for cbxEEPSubType item index
	int index = -1;
	int k;
	for (k = 0; ToolBar[k].cmdType != C_EndOfList; k++)
	{
		if (ToolBar[k].cmdId == cbxEEPSubType)
		{
			index = k;
			break;
		}
	}
	if (index > -1)
	{
		ToolBar[index].itemList = (void*) GetEEPSubTypeList(pritype);
		SetValue(cbxEEPSubType, 0, ChangeListPtr);
	}

	int j = GetEEPSubTypeIndex(type);
	if (j > -1)		//-1 significa non trovato
	{
	/**
		if (awip && strlen(awip->GetStringID()) > 0)
		{
			GetEEPSubTypeList(pritype)[j] = awip->GetStringID();
			SetValue(cbxEEPSubType, 0, ChangeList);
		}
	**/
		SetValue(cbxEEPSubType, j, Value);
	}

}

//==================>>> e2CmdWindow::UpdateChipType <<<=======================
void e2CmdWindow::UpdateChipType(int pritype, int subtype)
{
	if (pritype < 0)
		pritype = awip->GetEEPPriType();
	if (pritype == 0)
		pritype = E24XX;
	if (subtype < 0)
		subtype = awip->GetEEPSubType();

	SetValue(cbxEEPType, GetEEPTypeIndex(pritype), Value);
	SetChipSubType(pritype, subtype);
}

//==================>>> e2CmdWindow::UpdateMenuType <<<=======================
void e2CmdWindow::UpdateMenuType(long new_type)
{
	if (new_type == 0)
		new_type = BuildE2PType( awip->GetEEPPriType(), awip->GetEEPSubType() );

	//deseleziona il menu attuale
	if (type_index > 0)
		SetValue(type_index, 0, Checked);
	//seleziona il nuovo menu
	type_index = TypeToMenuId(new_type);
	if (type_index > 0)
		SetValue(type_index, 1, Checked);
}

//==================>>> e2CmdWindow::TypeToMenuId <<<=======================
int e2CmdWindow::TypeToMenuId(long type)
{
	int k;

	for (k = 0; index_menu_type[k].menu_id != 0; k++)
		if (index_menu_type[k].type == type)
			break;
	return index_menu_type[k].menu_id;
}

//==================>>> e2CmdWindow::MenuIdToType <<<=======================
long e2CmdWindow::MenuIdToType(int id)
{
	int k;

	for (k = 0; index_menu_type[k].menu_id != 0; k++)
		if (index_menu_type[k].menu_id == id)
			break;
	return index_menu_type[k].type;
}

//==================>>> e2CmdWindow::UpdateStrFromBuf <<<=======================
void e2CmdWindow::UpdateStrFromBuf()
{
	char *s;

	s = awip->GetStringID();
//	SetString(txtStringID, s);

	s = awip->GetComment();
	SetString(txtComment, s);
}

//==================>>> e2CmdWindow::UpdateStrFromStr <<<=======================
void e2CmdWindow::UpdateStrFromStr(char const *s1, char const *s2)
{
	if (s1)
	{
//		SetString(txtStringID, (char *)s1);
		awip->SetStringID(s1);
	}
	if (s2)
	{
		SetString(txtComment, (char *)s2);
		awip->SetComment(s2);
	}
}

HIDDEN char* filter[] = { "*.e2p",   "*.hex",   "*.mot",    "*.bin", "*.rom", "*.eep", "*", 0 };
//                         ^^^^^      ^^^^^      ^^^^^       ^^^^^
//                        form.E2P  form.Intel  form S-rec, form.Binario (Grezzo) - gli altri non aggiungono ulteriori formati
HIDDEN int filterIndex = 0;

HIDDEN void AddExtension(char *name)
{
	char *sp = strrchr(name, '.');	//cerca l'estensione
	if (sp == 0)
		strcat(name, filter[filterIndex]+1);	//gliela aggiunge
	else
	{	//controlla se e` gia` quella giusta
		if (strcasecmp(sp, filter[filterIndex]+1) != 0)
#ifdef __unix__
			strcat(name, filter[filterIndex]+1);
#else
			strcpy(sp, filter[filterIndex]+1);
#endif
	}
}

HIDDEN int CmpExtension(char const *name, char const *ext)
{
	int rv = 1;

	if ( name && strlen(name) &&
		 ext && strlen(ext) )
	{
		char *sp = strrchr(name, '.');	//cerca l'estensione
		if (sp)
			rv = strcasecmp(sp, ext);
	}

	return rv;
}

//====================>>> e2CmdWindow::OpenFile <<<====================
void e2CmdWindow::OpenFile(char const *file)
{
	char fn[256];
	int rval = 0;

	fn[0] = 0;

	if (file == 0 || strlen(file) == 0)
	{
		vFileSelect fsel(this);
		rval = fsel.FileSelect("Open Device Image File", fn, 255, filter, filterIndex);
	}
	else
	{
		rval = 1;
		strncpy(fn, file, 255);
		fn[255] = '\0';
	}

	if (rval)
	{
		if (fn[0] && FileExist(fn) )
		{
			char oldname[256];

			if (awip->GetFileName())
			{
				strncpy(oldname, awip->GetFileName(), 255);
				oldname[255] = '\0';
			}
			else
				oldname[0] = '\0';

			awip->SetFileName(fn);

			//Piccolo barbatrucco, se l'estensione del file
			//  caricato e` ".EEP" allora posiziona nel secondo
			//  banco delle splitted. Se l'eeprom in questione
			//  non e` splitted lo ignora.
			int split_bank = 0;
			if ( CmpExtension(fn, ".eep") == 0 )
				split_bank = 1;

		//--------
			rval = awip->Load(split_bank);
		//--------
			if (rval <= 0)
			{
				vNoticeDialog note(this);
				note.Notice("Unable to load the file");
			}
			else
			{
				if ( CmpExtension(fn, ".eep") == 0 )
					awip->SetFileName(oldname);
			//	else
			//		vCmdWindow::SetTitle(fn);
				SetTitle();

				UpdateStrFromBuf();
				first_line = 0;
				curIndex = 0;
				Draw();
			}
		}
		else
		{
			vNoticeDialog note(this);
			note.Notice("Unable to open the file");
		}
	}

	UpdateFileMenu();
}

//====================>>> e2CmdWindow::SaveFile <<<====================
void e2CmdWindow::SaveFile(int force_select)
{
	char fn[256];
	char const *fnp = awip->GetFileName();
	int err = 0;

	if (!force_select && fnp && *fnp)
	{	// Nome gia` assegnato, salva il file
//		awip->SetNoOfBlock(awip->GetNoOfBank());
		if ( (err = awip->Save()) <= 0 )
		{
			char str[128];
			vNoticeDialog note(this);
			sprintf(str, "Unable to save the file (%d)\n", err);
			note.Notice(str);
		}
	}
	else
	{	// Nome da assegnare, select e salva il file
		vFileSelect fsel(this);

		fn[0] = 0;
		if (fnp)
			strcpy(fn, fnp);
		if ( fsel.FileSelectSave("Save Device Image File As", fn, 255, filter, filterIndex) && fn[0] )
		{
			//Forza l'estensione
			AddExtension(fn);

			//Salva il nome vecchio, cosi nel caso il salvataggio
			//  non riuscisse lo ripristina
			char oldname[128];
			char *oldnamep;
			if (awip->GetFileName())
			{
				strcpy(oldname, awip->GetFileName());
				oldnamep = oldname;
			}
			else
				oldnamep = 0;

			awip->SetFileBuf((enum FileType)filterIndex);	//????? Ci vorrebbe un controllo separato dall'estensione sul tipo di file (combobox)
			awip->SetFileName(fn);
			if ( (err = awip->Save()) <= 0 )
			{
				char str[256];
				vNoticeDialog note(this);
				sprintf(str, "Unable to save the file %s (%d)\n", fn, err);
				note.Notice(str);
				//ripristina il nome precedente
				awip->SetFileName(oldnamep);
			}
			else
			{
				//Tutto OK, imposta il nuovo titolo
				//vCmdWindow::SetTitle(fn);
				SetTitle();
			}
		}
	}

	//If the Save is ok
	if (err > 0)
	{
		awip->BufChanged(0);
		UpdateStatusBar();
	}
}

void e2CmdWindow::SetTitle()
{
	if (awip->GetFileName() && strlen(awip->GetFileName()) > 0)
	{
		char str[128];

		sprintf(str, STR_TITLE, awip->GetFileName());
		vCmdWindow::SetTitle(str);
	}
	else
		vCmdWindow::SetTitle(DEF_TITLE);
}

const char *e2CmdWindow::GetFileName() const
{
	if (awip->GetFileName() && strlen(awip->GetFileName()) > 0)
		return awip->GetFileName();
	else
		return DEF_FNAME;
}

void e2CmdWindow::UpdateFileMenu()
{
	char *sp;

	sp = (char *)THEAPP->GetLastFile();
	if (sp)
	{
		char *p = strrchr(sp, '\\');
		SetStringAll(m_File1, p ? p+1 : sp);
		SetValueAll(m_File1, isSens, Sensitive);
	}
	else
	{
		SetStringAll(m_File1, "");
		SetValueAll(m_File1, notSens, Sensitive);
	}

	sp = (char *)THEAPP->GetPrevFile();
	if (sp)
	{
		char *p = strrchr(sp, '\\');
		SetStringAll(m_File2, p ? p+1 : sp);
		SetValueAll(m_File2, isSens, Sensitive);
	}
	else
	{
		SetStringAll(m_File2, "");
		SetValueAll(m_File2, notSens, Sensitive);
	}
}

void e2CmdWindow::PostInit()
{
	vFont font90(vfDefaultFixed);
	e2Canvas->SetFont(font90);

	UpdateStrFromBuf();
	SetTitle();
	first_line = 0;
	curIndex = 0;
	Draw();
	UpdateChipType();
	UpdateMenuType();

	char const *sp = GetEEPTypeString(awip->GetEEPPriType(), awip->GetEEPSubType());
	UpdateStrFromStr(sp);
	UpdateStatusBar();

	UpdateFileMenu();

	if ( THEAPP->GetBogoMips() == 0 )
	{
		vNoticeDialog note(this);
		note.Notice("You need to run Calibration from the Options menu\nbefore any read/write operations");
	}
	if ( THEAPP->GetParPortNo() < 0 )
	{
		vNoticeDialog note(this);
		note.Notice("You need to run Setup from the Options menu\nbefore any read/write operations");
	}
}

//====================>>> e2CmdWindow::NextLine <<<====================
int e2CmdWindow::NextLine()
{
	int no_line = awip->GetSize() / awip->GetHexPerLine();
	int rows = e2Canvas->GetRows() - 1;

	if ( first_line < no_line - rows )
	{
		first_line++;
		Draw();
	}
	return first_line;
}

//====================>>> e2CmdWindow::PrevLine <<<====================
int e2CmdWindow::PrevLine()
{
	if ( first_line > 0 )
	{
		first_line--;
		Draw();
	}
	return first_line;
}

//====================>>> e2CmdWindow::NextPage <<<====================
int e2CmdWindow::NextPage()
{
	int no_line = awip->GetSize() / awip->GetHexPerLine();
	int rows = e2Canvas->GetRows() - 1;

	if ( first_line < no_line - rows )
	{
		first_line += rows;
			if (first_line > no_line - rows)
				first_line = no_line - rows;
		Draw();
	}
	return first_line;
}

//====================>>> e2CmdWindow::PrevPage <<<====================
int e2CmdWindow::PrevPage()
{
	int rows = e2Canvas->GetRows() - 1;

	if ( first_line > 0 )
	{
		first_line -= rows;
		if (first_line < 0)
			first_line = 0;
		Draw();
	}
	return first_line;
}

//====================>>> e2CmdWindow::FirstPage <<<====================
void e2CmdWindow::FirstPage()
{
	int no_line = awip->GetSize() / awip->GetHexPerLine();
	int rows = e2Canvas->GetRows() - 1;

	if (no_line > rows)
	{
		first_line = 0;
		Draw();
	}
}

//====================>>> e2CmdWindow::LastPage <<<====================
void e2CmdWindow::LastPage()
{
	int no_line = awip->GetSize() / awip->GetHexPerLine();
	int rows = e2Canvas->GetRows() - 1;

	if ( no_line > rows )
	{
		first_line = no_line - rows;
		Draw();
	}
}

//====================>>> e2CmdWindow::ScrollV <<<====================
void e2CmdWindow::ScrollV(int top)
{
	int no_line = awip->GetSize() / awip->GetHexPerLine();
	int rows = e2Canvas->GetRows() - 1;

#if 0
	// first_line : no_line-rows = top : 100
	first_line = top * (no_line - rows) / 100;	//** 01/05/1998 **
#else
	// first_line : no_line : top : 100
	first_line = top * no_line / 100;
#endif
	if ( first_line < 0 )
		first_line = 0;
	else
	if ( first_line > no_line - rows )
		first_line = no_line - rows;

	Draw();
}

//*** 13/09/99
//const int Hex1_s = 6;
const int Hex1_s = 10;
const int Hex1_e = Hex1_s+23;
const int Hex2_s = Hex1_e+3;
const int Hex2_e = Hex2_s+23;
const int Ascii_s = Hex2_e+4;
const int Ascii_e = Ascii_s+16;

//==================>>> e2CmdWindow::CoordToIndex <<<===================
int e2CmdWindow::CoordToIndex(int row, int col)
{
	int index = -1;

	//first 8 bytes
	if ( col >= Hex1_s && col < Hex1_e )
	{
		col -= Hex1_s;
		if ((col % 3) != 2)
		{
			index = col / 3;
			col = index * 3 + Hex1_s;
		}
	}
	else
	//second 8 bytes
	if ( col >= Hex2_s && col < Hex2_e )
	{
		col -= Hex2_s;
		if ((col % 3) != 2)
		{
			index = 8 + col / 3;
			col = (index - 8)*3 + Hex2_s;
		}
	}
	else
	//ascii 16 chars
	if ( col >= Ascii_s && col < Ascii_e )
	{
		index = col - Ascii_s;
	}

	if (index > -1)
	{
		// index contiene l'indice all'interno del buffer del char da cambiare
		index += (first_line + row) * 16;
	}

	return index;
}

//==================>>> e2CmdWindow::IndexToCoord <<<===================
void e2CmdWindow::IndexToCoord(int index, int &row, int &col)
{
	row = -1;
	col = -1;

	if (index > -1)
	{
		int crow = index / 16;

		if (crow < first_line + e2Canvas->GetRows() - 1)
			row = crow - first_line;

		int ccol = index % 16;

		if (ccol > 7)
			col = (ccol - 8) * 3 + Hex2_s;
		else
			col = ccol * 3 + Hex1_s;
	}
}

//====================>>> e2CmdWindow::CharEdit <<<==================
void e2CmdWindow::CharEdit(int row, int col)
{
	if ( !editbuf_enabled || !awip->IsBufferValid() )
		return;

	if (row == -1 && col == -1)
	{
		if (curIndex >= awip->GetSize())
			curIndex = 0;

		int rv = (awip->GetBufPtr())[curIndex];

		editModalDialog ed(this,rv);
		if ( ed.editAction("Insert the new value", rv) )
		{
			(awip->GetBufPtr())[curIndex] = rv;

			awip->RecalcCRC();
			awip->BufChanged();
			UpdateStatusBar();
		}
		if (++curIndex >= awip->GetSize())
			curIndex = 0;

		Draw();
	}
	else
	{
		int index = CoordToIndex(row, col);

		if (index > -1)
		{
			if (index >= awip->GetSize())
				return;

			curIndex = index + 1;

			if (col >= Ascii_s)
			{
				char str[256];                // a buffer for reply
				char *sp;

				int k;
				sp = (char *)awip->GetBufPtr() + index;
				for (k = 0; k < 255 && isprint(*sp); k++, sp++)
				{
					str[k] = *sp;
				}
				str[k] = '\0';

				editModalDialog2 ed(this, str);
				sprintf(str, "Enter text from location %04Xh", index);
				sp = str;
				if ( ed.editAction(str,sp,255) )
				{
					while (*sp && index < awip->GetBufSize())
						(awip->GetBufPtr())[index++] = *sp++;
					awip->RecalcCRC();
					awip->BufChanged();
					UpdateStatusBar();
				}
			}
			else
			{
				int rv = (awip->GetBufPtr())[index];

				editModalDialog ed(this,rv);
				if ( ed.editAction("Insert the new value", rv) )
				{
					(awip->GetBufPtr())[index] = rv;

					awip->RecalcCRC();
					awip->BufChanged();
					UpdateStatusBar();
				}
			}

			if (curIndex >= awip->GetSize())
				curIndex = 0;
			Draw();
		}
	}
}

//====================>>> e2CmdWindow::Draw <<<====================
void e2CmdWindow::Draw(int rows, int cols)
{
	if (awip == 0)
		return;			// ** Vlib 1.22 call Draw before the AppWinInfo is created ** 28/08/99

	if ( !awip->IsBufferValid() )	// ** 01/05/1998 **
		return;

	int no_line;
	int new_top, new_shown;
	int k;

	int size = awip->GetSize();// ? awip->GetSize() : awip->GetBufSize();

	no_line = (size + awip->GetHexPerLine() - 1) / awip->GetHexPerLine();

	if (!rows)
		rows = e2Canvas->GetRows();

	rows--;				// per evitare lo scrolling

	//Caso in cui non c'e` file o tutto il file sta nella finestra
	if (no_line == 0 || rows >= no_line)
	{
		first_line = 0;
		e2Canvas->ShowVScroll(0);	// Hide Vert Scroll
	}
	else
	{
		//Caso in cui si ingrandisce una finestra che contiene un file
		// visualizzato in fondo
		if (rows > no_line - first_line)
		{
			first_line = no_line - rows;
			if (first_line < 0)
				first_line = 0;
		}

		// rows : no_line = shown : 100
		new_shown = rows * 100 / no_line;

		// first_line : no_line-rows = top : 100
		new_top = first_line * 100 / (no_line - rows);

		e2Canvas->SetVScroll(new_shown, new_top);
		e2Canvas->ShowVScroll(1);	// Show Vert Scroll
	}

//	e2Canvas->Clear();
	e2Canvas->GotoRC(0,0);
	for (k = first_line; k < first_line + rows && k < no_line; k++)
	{
#ifdef	_NO_COLOR
		e2Canvas->DrawText(awip->Dump(k));
#else
		e2Canvas->DrawAttrText(awip->Dump(k,1), ChRed + ChDimColor);
		e2Canvas->DrawAttrText(awip->Dump(k,2), ChBlue + ChDimColor);
		e2Canvas->DrawAttrText(awip->Dump(k,3), ChMagenta + ChDimColor);
#endif
	}
	e2Canvas->ClearToEnd(k-first_line, 0);

	int r = -1, c = -1;
	if (editbuf_enabled)
		IndexToCoord(curIndex, r, c);

	if (r > -1 && c > -1)
	{
		e2Canvas->GotoRC(r,c);
		e2Canvas->ShowTextCursor();
	}
	else
		e2Canvas->HideTextCursor();
}

//====================>>> e2CmdWindow::Print <<<====================
void e2CmdWindow::Print()
{
	int no_line = (awip->GetSize() + awip->GetHexPerLine() - 1) / awip->GetHexPerLine();
	int k;
	int a,b,cHeight;
	int curRow = 0, curPage = 0;
    // Print current picture

    vPrintDC pdc;               // create a vPrintDC object
    vPrinter printer;           // and a printer to set attributes

    printer.Setup("test.prn");   // setup the printer
    pdc.SetPrinter(printer);    // change to the printer we setup

    if (!pdc.BeginPrinting())   // call BeginPrinting first
        return;

    pdc.SetTranslate(36,36);    // Add 1/2" (36 * 1/72") margins

	pdc.TextHeight(a,b);
	cHeight = a+b;
	char str[256];

	k = 0;
	while (k < no_line)
	{
		pdc.BeginPage();
		curRow = 0;
		sprintf(str, "Page %d   ---   " APPNAME " by " AUTHORNAME , ++curPage);
		pdc.DrawText(0,curRow++ * cHeight, str);
		if (curPage == 1)
		{
			curRow++;
			sprintf(str, "File  : %s", GetFileName());
			pdc.DrawText(0,curRow++ * cHeight, str);
			sprintf(str, "Device: %s", awip->GetStringID());
			pdc.DrawText(0,curRow++ * cHeight, str);
			sprintf(str, "Note  : %s", awip->GetComment());
			pdc.DrawText(0,curRow++ * cHeight, str);
			sprintf(str, "Size  : %ld Bytes    CRC: %04X", GetDevSize(), awip->GetCRC());
			pdc.DrawText(0,curRow++ * cHeight, str);
		}
		curRow++;
		for (; k < no_line && curRow < 66; k++)
		{
			pdc.DrawText(0, curRow++ * cHeight,(char *)awip->Dump(k));
		}
		pdc.EndPage();
	}

    pdc.EndPrinting();          // Finish printing
}

HIDDEN int FileExist(char const *name)
{
	FILE *fh;
	int rval = 0;

	if ( (fh = fopen(name, "rb")) )
	{
		rval = 1;
		fclose(fh);
	}

	return rval;
}
