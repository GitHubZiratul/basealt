//=========================================================================//
//-------------------------------------------------------------------------//
// fusemdlg.cpp -- Fuse modal dialog                                       //
// This file is part of PonyProg.                                          //
//-------------------------------------------------------------------------//
//                                                                         //
//  PonyProg - Serial Device Programmer                                    //
//                                                                         //
//  Copyright (C) 1997-2000   Claudio Lanconelli                           //
//                                                                         //
//  e-mail: lanconel@cs.unibo.it                                           //
//  http://www.cs.unibo.it/~lanconel                                       //
//                                                                         //
//-------------------------------------------------------------------------//
//                                                                         //
// This program is free software; you can redistribute it and/or           //
// modify it under the terms of the GNU  General Public License            //
// as published by the Free Software Foundation; either version2 of        //
// the License, or (at your option) any later version.                     //
//                                                                         //
// This program is distributed in the hope that it will be useful,         //
// but WITHOUT ANY WARRANTY; without even the implied warranty of          //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       //
// General Public License for more details.                                //
//                                                                         //
// You should have received a copy of the GNU  General Public License      //
// along with this program (see COPYING);     if not, write to the         //
// Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. //
//                                                                         //
//-------------------------------------------------------------------------//
//=========================================================================//

//=======================================================================
//@V@:Note: This file generated by vgen V1.07 (12:35:57 03 Oct 1999).
//	fusemdlg.cpp:	Source for fuseModalDialog class
//=======================================================================

#include <stdio.h>
#include <stdlib.h>

#include "fusemdlg.h"
#include <v/vnotice.h>

#include "eeptypes.h"

typedef struct {
	long type;
	int lockenabled;
	int fuseenabled;
	char *locklabel[8];
	char *fuselabel[8];
} FuseBit;

static FuseBit labels[] = {
	{AT90S0000, 0x06, 0x00, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,0}},

	{AT90S1200, 0x06, 0x00, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,0}},
	{AT90S2313, 0x06, 0x00, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,0}},
	{AT90S4414, 0x06, 0x00, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,0}},
	{AT90S8515, 0x06, 0x00, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,0}},

	{AT90S4434, 0x06, 0x01, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,"FSTRT "}},
	{AT90S8535, 0x06, 0x01, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,"FSTRT "}},

	{AT90S2333, 0x06, 0x1f, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,"SPIEN ","BODLEVEL ","BODEN ","CKSEL2 ","CKSEL1 ","CKSEL0 "}},
	{AT90S4433, 0x06, 0x1f, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,"SPIEN ","BODLEVEL ","BODEN ","CKSEL2 ","CKSEL1 ","CKSEL0 "}},

	{AT90S2323, 0x06, 0x01, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,"FSTRT "}},
	{AT90S2343, 0x06, 0x01, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,"RCEN "}},

	{AT90S8534, 0x06, 0x00, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,0}},

	{ATtiny10, 0x06, 0x00, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,0}},
	{ATtiny11, 0x06, 0x00, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,0}},

	{ATtiny12, 0x06, 0xFF, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {"BODLEVEL ","BODEN ","SPIEN ","RSTDISBL ","CKSEL3 ","CKSEL2 ","CKSEL1 ","CKSEL0 "}},
	{ATtiny22, 0x06, 0x01, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,0,0,0,"RCEN "}},

	{ATmega603, 0x06, 0x0B, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,"EESAVE ",0,"SUT1 ","SUT0 "}},
	{ATmega103, 0x06, 0x0B, {0,0,0,0,0,"Lock2 ","Lock1 ",0}, {0,0,0,0,"EESAVE ",0,"SUT1 ","SUT0 "}},

	{PIC1684, 0x00, 0x1F, {0}, {0,0,0,"CP ","PWRTE ","WDTE ","FOSC1 ","FOSC0 "}},

	{AT89S8252, 0xe0, 0x00, {"LB1 ","LB2 ","LB3 ",0,0,0,0,0}, {0,0,0,0,0,0,0,0}},
	{AT89S53, 0xe0, 0x00, {"LB1 ","LB2 ","LB3 ",0,0,0,0,0}, {0,0,0,0,0,0,0,0}},

	{0, 0, 0, {0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0}}	//End tag
};

static int FindLabels(long type)
{
	int k;
	int retval = -1;

	for (k = 0; labels[k].type; k++)
	{
		if (labels[k].type == type)
		{
			retval = k;
			break;
		}
	}

	return retval;
}

int SetCommandObject(const int id, const int val, CommandObject* CmdList);
int SetCommandSensitive(const int id, const int val, CommandObject* CmdList);
int SetCommandLabel(const int id, char *str, CommandObject* CmdList);

int GetCommandObject(const int id, CommandObject* CmdList);

//@V@:BeginIDs
enum {
	lblMainMsg = 5000,

	frmFuses,

	chk0,
	chk1,
	chk2,
	chk3,
	chk4,
	chk5,
	chk6,
	chk7,

	chk8,
	chk9,
	chk10,
	chk11,
	chk12,
	chk13,
	chk14,
	chk15,

	blk1,
	blk2,

	frmFill,

	lblFrom,
	lblTo,  
	lblVal, 

	txiFrom,
	txiTo,  
	txiVal,

	btn0,
	btn1,
	btnProg
};
//@V@:EndIds

static char *deflbl[] = {
	" 1",
	" 2",
	" 3",
	" 4",
	" 5",
	" 6",
	" 7",
	" 8",
	" 9",
	"10",
	"11",
	"12",
	"13",
	"14",
	"15",
	"16"
};

//@V@:BeginDialogCmd DefaultCmds
static DialogCmd FuseDialogCmds[] =
{
	{C_Label, lblMainMsg, 0,"X",NoList,CA_MainMsg,isSens,NoFrame, 0, 0},

	{C_Frame, frmFuses,0,"Fuses",NoList,CA_None,isSens,NoFrame,0,lblMainMsg},

	{C_CheckBox, chk0, 0," 1",NoList,CA_None,isSens,frmFuses,0,0},
	{C_CheckBox, chk1, 0," 2",NoList,CA_None,isSens,frmFuses,chk0,0},
	{C_CheckBox, chk2, 0," 3",NoList,CA_None,isSens,frmFuses,chk1,0},
	{C_CheckBox, chk3, 0," 4",NoList,CA_None,isSens,frmFuses,chk2,0},
	{C_CheckBox, chk4, 0," 5",NoList,CA_None,isSens,frmFuses,chk3,0},
	{C_CheckBox, chk5, 0," 6",NoList,CA_None,isSens,frmFuses,chk4,0},
	{C_CheckBox, chk6, 0," 7",NoList,CA_None,isSens,frmFuses,chk5,0},
	{C_CheckBox, chk7, 0," 8",NoList,CA_None,isSens,frmFuses,chk6,0},

	{C_CheckBox, chk8, 0," 9",NoList,CA_None,isSens,frmFuses,0,chk0},
	{C_CheckBox, chk9, 0,"10",NoList,CA_None,isSens,frmFuses,chk8,chk0},
	{C_CheckBox, chk10, 0,"11",NoList,CA_None,isSens,frmFuses,chk9,chk0},
	{C_CheckBox, chk11, 0,"12",NoList,CA_None,isSens,frmFuses,chk10,chk0},
	{C_CheckBox, chk12, 0,"13",NoList,CA_None,isSens,frmFuses,chk11,chk0},
	{C_CheckBox, chk13, 0,"14",NoList,CA_None,isSens,frmFuses,chk12,chk0},
	{C_CheckBox, chk14, 0,"15",NoList,CA_None,isSens,frmFuses,chk13,chk0},
	{C_CheckBox, chk15, 0,"16",NoList,CA_None,isSens,frmFuses,chk14,chk0},

	{C_Blank, blk1, 0, " ",NoList,CA_None,isSens,NoFrame,0,frmFuses},

	{C_Button,M_Cancel,0,
#ifdef	_WINDOWS
		" &Cancel ",
#else
		" Cancel ",
#endif
					NoList,CA_None,isSens,NoFrame,0,blk1},
	{C_Button,M_OK,0,
#ifdef	_WINDOWS
		" &OK ",
#else
		" OK ",
#endif
					NoList,CA_DefaultButton,isSens,NoFrame,M_Cancel,blk1},

	{C_Blank, blk2, 0, " ",NoList,CA_None,isSens,NoFrame,M_OK,blk1},

	{C_Button,btn0,0,
#ifdef	_WINDOWS
		" C&lear All ",
#else
		" Clear All ",
#endif
					NoList,CA_None,isSens,NoFrame,blk2,blk1, 0,"All bits to '0'"},
	{C_Button,btn1,0,
#ifdef	_WINDOWS
		" &Set All ",
#else
		" Set All ",
#endif
					NoList,CA_None,isSens,NoFrame,btn0,blk1, 0, "All bits to '1'"},
	{C_Button,btnProg,0,
#ifdef	_WINDOWS
		" &Program ",
#else
		" Program ",
#endif
					NoList,CA_None,isSens,NoFrame,btn1,blk1, 0, "Program selected bits"},

	{C_EndOfList,0,0,0,0,CA_None,0,0,0}
};

static DialogCmd BlockDialogCmds[] =
{
	{C_Label, lblMainMsg, 0,"X",NoList,CA_MainMsg,isSens,NoFrame, 0, 0},

	{C_Frame, frmFuses,0,"Blocks",NoList,CA_None,isSens,NoFrame,0,lblMainMsg},

	{C_Frame, frmFill,0,"",NoList,CA_None,isSens,frmFuses,0,0},
	{C_Label, lblFrom,0, " First Block to Lock",NoList,CA_None,isSens,frmFill,0,0},
	{C_Label, lblTo,  0, " N.of Blocks to Lock",NoList,CA_None,isSens,frmFill,0,lblFrom},
	{C_Label, lblVal, 0, " High endurance block",NoList,CA_None,isSens,frmFill,0,lblTo},

	{C_TextIn,txiFrom,0,"",NoList,CA_None,isSens,frmFuses,frmFill,0,8,"From address"},
	{C_TextIn,txiTo,  0,"",NoList,CA_None,isSens,frmFuses,frmFill,txiFrom,8,"To address"},
	{C_TextIn,txiVal, 0,"",NoList,CA_None,isSens,frmFuses,frmFill,txiTo,8,"Byte value"},

	{C_Blank, blk1, 0, " ",NoList,CA_None,isSens,NoFrame,0,frmFuses},

	{C_Button,M_Cancel,0,
#ifdef	_WINDOWS
		" &Cancel ",
#else
		"  Cancel ",
#endif
					NoList,CA_None,isSens,NoFrame,0,blk1},
	{C_Button,M_OK,0,
#ifdef	_WINDOWS
		" &OK ",
#else
		"  OK ",
#endif
					NoList,CA_DefaultButton,isSens,NoFrame,M_Cancel,blk1},

	{C_EndOfList,0,0,0,0,CA_None,0,0,0}
};
//@V@:EndDialogCmd


//======================>>> fuseModalDialog::fuseModalDialog <<<==================
fuseModalDialog::fuseModalDialog(vBaseWindow* bw, char* title) :
				vModalDialog(bw, title)
{
	UserDebug(Constructor,"fuseModalDialog::fuseModalDialog()\n")

	cmdw = (e2CmdWindow *)bw;
	write = 0;
}

//===================>>> fuseModalDialog::~fuseModalDialog <<<====================
fuseModalDialog::~fuseModalDialog()
{
	UserDebug(Destructor,"fuseModalDialog::~fuseModalDialog() destructor\n")
}

//====================>>> fuseModalDialog::fuseAction <<<====================
int fuseModalDialog::fuseAction(char* msg, long type, int &lock, int &fuse, int readonly)
{
	char str1[10], str2[10], str3[10];
	
	int k;
	int j = FindLabels(type);
	if (j >= 0)
	{
		//Label
		for (k = 0; k < 8; k++)
		{
			char *sp;

			sp = labels[j].locklabel[k];
			if (!sp)
				sp = deflbl[k];
			SetCommandLabel(chk0+k, sp, FuseDialogCmds);

			sp = labels[j].fuselabel[k];
			if (!sp)
				sp = deflbl[k+8];
			SetCommandLabel(chk8+k, sp, FuseDialogCmds);
		}

		//Sensitive
		for (k = 0; k < 8; k++)
		{
			SetCommandSensitive(chk0+k, (labels[j].lockenabled & (0x80>>k)) ? 1 : 0, FuseDialogCmds);
			SetCommandSensitive(chk8+k, (labels[j].fuseenabled & (0x80>>k)) ? 1 : 0, FuseDialogCmds);
		}
	}
	else
	{	//Default
		//Label
		for (k = 0; k < 8; k++)
		{
			SetCommandLabel(chk0+k, deflbl[k], FuseDialogCmds);
			SetCommandLabel(chk8+k, deflbl[k+8], FuseDialogCmds);
		}

		//Sensitive
		for (k = 0; k < 8; k++)
		{
			SetCommandSensitive(chk0+k, 1, FuseDialogCmds);
			SetCommandSensitive(chk8+k, 1, FuseDialogCmds);
		}
	}

	//Checked
	for (k = 0; k < 8; k++)
	{
		SetCommandObject(chk0+k, (lock & (0x80>>k)) ? 1 : 0, FuseDialogCmds);
		SetCommandObject(chk8+k, (fuse & (0x80>>k)) ? 1 : 0, FuseDialogCmds);
	}

	sprintf(str1, "%d", (lock >> 4) & 0x0F);
	sprintf(str2, "%d", lock & 0x0F);
	sprintf(str3, "%d", fuse & 0x0F);
	SetCommandLabel(txiFrom, str1, BlockDialogCmds);
	SetCommandLabel(txiTo, str2, BlockDialogCmds);
	SetCommandLabel(txiVal, str3, BlockDialogCmds);

	if (readonly)
	{
		SetCommandSensitive(M_OK, 0, FuseDialogCmds);
		SetCommandSensitive(btnProg, 0, FuseDialogCmds);
		SetCommandSensitive(btn0, 0, FuseDialogCmds);
		SetCommandSensitive(btn1, 0, FuseDialogCmds);

		SetCommandSensitive(M_OK, 0, BlockDialogCmds);
	}
	else
	{
		SetCommandSensitive(M_OK, 1, FuseDialogCmds);
		SetCommandSensitive(btnProg, 1, FuseDialogCmds);
		SetCommandSensitive(btn0, 1, FuseDialogCmds);
		SetCommandSensitive(btn1, 1, FuseDialogCmds);

		SetCommandSensitive(M_OK, 1, BlockDialogCmds);
	}

	if (type == E2464)
		AddDialogCmds(BlockDialogCmds);		// add security block commands
	else
		AddDialogCmds(FuseDialogCmds);		// add fuses commands

	ItemVal ans,rval;

	write = 0;

	ans = ShowModalDialog(msg,rval);
	if (ans == M_Cancel)
		return 0;

	// *** Add code to process dialog values here
	lock = 0;
	fuse = 0;

	if (type == E2464)
	{
		GetTextIn(txiFrom, str1, 8);
		int From = strtol(str1,NULL,0);

		GetTextIn(txiTo, str2, 8);
		int To = strtol(str2,NULL,0);

		GetTextIn(txiVal, str3, 8);
		int Val = strtol(str3,NULL,0);

		lock = ((From << 4) & 0xF0) | (To & 0x0F);
		fuse = Val & 0x0F;
	}
	else
	{
		for (k = 0; k < 8; k++)
		{
			lock |= GetValue(chk0+k) ? (0x80>>k) : 0;
			fuse |= GetValue(chk8+k) ? (0x80>>k) : 0;
		}
	}

	if (ans == M_OK)
	{
		if (write)
			return 2;
		else
			return 1;
	}
	else
		return 0;
}

//====================>>> fuseModalDialog::DialogCommand <<<====================
void fuseModalDialog::DialogCommand(ItemVal id, ItemVal retval, CmdType ctype)
{
	UserDebug2(CmdEvents,"fuseModalDialog::DialogCommand(id:%d, val:%d)\n",id, retval)

	switch (id)		// We will do some things depending on value
	{
	case btn0:
		{
			int k;
			for (k = 0; k < 8; k++)
			{
				SetValue(chk0+k, 0, Value);
				SetValue(chk8+k, 0, Value);
			}
		}
		break;
	case btn1:
		{
			int k;
			for (k = 0; k < 8; k++)
			{
				SetValue(chk0+k, 1, Value);
				SetValue(chk8+k, 1, Value);
			}
		}
		break;
	
	case btnProg:
		//Execute the command
		write = 1;

		vModalDialog::DialogCommand(id,retval,ctype);
		fuseModalDialog::DialogCommand(M_OK,1,ctype);
		break;
	default:
		vModalDialog::DialogCommand(id,retval,ctype);
		break;
	}
}

//========================>>> SetCommandObject <<<==============================
int SetCommandObject(const int id, const int val, CommandObject* CmdList)
{
	for (CommandObject* cur = CmdList ; cur->cmdType != C_EndOfList ; ++cur)
	{
		if (cur->cmdId == id)
		{
			cur->retVal = val;
			return 1;
		}
	}

	SysDebug1(BadVals,"SetCommandObject(id:%d...) - No match in list\n",id)

	return 0;
}

//========================>>> SetCommandSensitive <<<==============================
int SetCommandSensitive(const int id, const int val, CommandObject* CmdList)
{
	for (CommandObject* cur = CmdList ; cur->cmdType != C_EndOfList ; ++cur)
	{
		if (cur->cmdId == id)
		{
			cur->Sensitive = val;
			return 1;
		}
	}

	SysDebug1(BadVals,"SetCommandObject(id:%d...) - No match in list\n",id)

	return 0;
}

//========================>>> SetCommandLabel <<<==============================
int SetCommandLabel(const int id, char *str, CommandObject* CmdList)
{
	for (CommandObject* cur = CmdList ; cur->cmdType != C_EndOfList ; ++cur)
	{
		if (cur->cmdId == id)
		{
			cur->title = str;
			return 1;
		}
	}

	SysDebug1(BadVals,"SetCommandObject(id:%d...) - No match in list\n",id)

	return 0;
}

//========================>>> GetCommandObject <<<==============================
int GetCommandObject(const int id, CommandObject* CmdList)
{
	for (CommandObject* cur = CmdList ; cur->cmdType != C_EndOfList ; ++cur)
	{
		if (cur->cmdId == id)
		{
			return cur->retVal;
		}
	}

	SysDebug1(BadVals,"GetCommandObject(id:%d...) - No match in list\n",id)

	return 0;
}
// --------------------------------------------------------------------- 
